<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide Git</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <aside>
        <h1>üîÄ Guide Git</h1>
        <p class="subtitle">Toutes les commandes Git expliqu√©es simplement</p>
        <p>
            <a href="html-guide.html">Guide HTML</a>
            <a href="css-guide.html">Guide CSS</a>
            <a href="js-guide.html">Guide JavaScript</a>
            <a href="bootstrap-guide.html">Guide Bootstrap</a>
        </p>
    </aside>

    <nav>
        <div class="nav-logo">
            <svg viewBox="0 0 92 92" xmlns="http://www.w3.org/2000/svg">
                <path fill="#F05032" d="M90.156 41.965L50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371l40.12 40.118a5.918 5.918 0 0 0 8.371 0l39.931-39.934a5.914 5.914 0 0 0 0-8.367"/>
            </svg>
        </div>
        <ul>
            <li><a href="#config">Configuration</a></li>
            <li><a href="#base">Commandes de Base</a></li>
            <li><a href="#branches">Branches</a></li>
            <li><a href="#remote">Remote & Sync</a></li>
            <li><a href="#history">Historique</a></li>
            <li><a href="#advanced">Avanc√©</a></li>
            <li><a href="#undo">Annuler/Corriger</a></li>
        </ul>
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Rechercher..." />
        </div>
    </nav>

    <main>
        <section id="config">
            <h2>‚öôÔ∏è Configuration</h2>

            <div class="tag-card">
                <h3>git config --global user.name "ton nom"</h3>
                <p><strong>C'est quoi ?</strong> Configure ton nom d'utilisateur Git qui appara√Ætra sur tous tes commits. C'est ton identit√© dans Git ! Le --global applique ce r√©glage √† tous tes projets sur ta machine.</p>
                <p><strong>Pourquoi ?</strong> Git a besoin de savoir qui fait les modifications. Ton nom appara√Æt dans l'historique des commits pour que tout le monde sache qui a √©crit quoi. Essentiel pour le travail en √©quipe !</p>
                <p><strong>Premi√®re fois :</strong> √Ä faire une seule fois apr√®s l'installation de Git. Sans √ßa, Git refusera de faire des commits. Utilise ton vrai nom ou ton pseudo GitHub.</p>
                <code>git config --global user.name "Marie Dupont"
git config --global user.name "DevMaster42"</code>
            </div>

            <div class="tag-card">
                <h3>git config --global user.email "email@exemple.com"</h3>
                <p><strong>C'est quoi ?</strong> Configure ton email Git qui sera associ√© √† tous tes commits. Comme le nom, mais pour l'email. Le --global l'applique partout sur ta machine.</p>
                <p><strong>Pourquoi ?</strong> Ton email permet de te contacter et lie tes commits √† ton compte GitHub/GitLab. Si l'email correspond √† ton compte GitHub, tes contributions appara√Ætront dans ton profil (les petits carr√©s verts) !</p>
                <p><strong>Astuce GitHub :</strong> Utilise le m√™me email que ton compte GitHub pour que tes commits soient compt√©s dans tes contributions. GitHub peut aussi g√©n√©rer un email priv√© (noreply) si tu veux rester anonyme.</p>
                <code>git config --global user.email "marie@exemple.com"
git config --global user.email "123456+user@users.noreply.github.com"</code>
            </div>

            <div class="tag-card">
                <h3>git config --list</h3>
                <p><strong>C'est quoi ?</strong> Affiche toute ta configuration Git actuelle : nom, email, √©diteur par d√©faut, alias, etc. Pratique pour v√©rifier que tout est bien configur√©.</p>
                <p><strong>Pourquoi ?</strong> Pour checker rapidement tes param√®tres ! Tu viens d'installer Git ? V√©rifie avec git config --list que ton nom et email sont bien configur√©s. Tu as un probl√®me ? Regarde si un param√®tre bizarre est configur√©.</p>
                <p><strong>Filtrer :</strong> Trop de lignes ? Utilise git config --global --list pour voir seulement les configs globales, ou git config user.name pour voir juste ton nom.</p>
                <code>git config --list
git config --global --list
git config user.name
git config user.email</code>
            </div>

            <div class="tag-card">
                <h3>git config --global core.editor "nom_editeur"</h3>
                <p><strong>C'est quoi ?</strong> D√©finit l'√©diteur de texte que Git utilisera pour les messages de commit, r√©solutions de conflits, etc. Par d√©faut c'est vim (difficile pour d√©butants).</p>
                <p><strong>Pourquoi ?</strong> Vim c'est puissant mais compliqu√© ! Si tu gal√®res avec vim, configure ton √©diteur pr√©f√©r√© : VS Code, nano, notepad++. Les messages de commit s'ouvriront dans ton √©diteur familier.</p>
                <p><strong>√âditeurs courants :</strong> VS Code : "code --wait", Nano : "nano", Sublime : "subl -n -w", Notepad++ : "notepad++". Le --wait est important pour que Git attende la fermeture de l'√©diteur.</p>
                <code>git config --global core.editor "code --wait"
git config --global core.editor "nano"
git config --global core.editor "subl -n -w"</code>
            </div>
        </section>

        <section id="base">
            <h2>üöÄ Commandes de Base</h2>

            <div class="tag-card">
                <h3>git init</h3>
                <p><strong>C'est quoi ?</strong> Initialise un nouveau d√©p√¥t Git dans le dossier actuel. Cr√©e un dossier cach√© .git qui contient toute l'histoire et la config du projet. C'est la toute premi√®re commande pour d√©marrer un projet Git !</p>
                <p><strong>Pourquoi ?</strong> Pour transformer un dossier normal en projet Git ! Sans git init, Git ne peut rien faire. Cette commande cr√©e la base de donn√©es Git locale qui trackera toutes tes modifications.</p>
                <p><strong>Attention :</strong> √Ä faire UNE SEULE FOIS par projet, dans le dossier racine. Ne fais JAMAIS git init dans un dossier qui contient d√©j√† un .git (projet d√©j√† initialis√©) !</p>
                <code>cd mon-projet
git init
# Initialized empty Git repository in mon-projet/.git/</code>
            </div>

            <div class="tag-card">
                <h3>git clone &lt;url&gt;</h3>
                <p><strong>C'est quoi ?</strong> T√©l√©charge un d√©p√¥t Git distant (GitHub, GitLab) sur ton ordinateur avec tout son historique. Cr√©e un dossier avec le nom du projet et configure automatiquement le remote "origin".</p>
                <p><strong>Pourquoi ?</strong> Pour r√©cup√©rer un projet existant ! Tu veux contribuer √† un projet GitHub ? git clone. Tu changes d'ordinateur ? git clone. C'est comme t√©l√©charger mais avec tout l'historique Git en plus.</p>
                <p><strong>HTTPS vs SSH :</strong> HTTPS : plus simple, demande mot de passe. SSH : plus s√©curis√©, n√©cessite cl√© SSH configur√©e. Les deux marchent, SSH est mieux pour usage fr√©quent (pas de mot de passe √† taper).</p>
                <code>git clone https://github.com/user/projet.git
git clone git@github.com:user/projet.git
git clone &lt;url&gt; mon-dossier  # Clone dans un dossier sp√©cifique</code>
            </div>

            <div class="tag-card">
                <h3>git status</h3>
                <p><strong>C'est quoi ?</strong> Affiche l'√©tat actuel de ton d√©p√¥t : fichiers modifi√©s, fichiers en staging, fichiers non track√©s, branche actuelle. C'est LE commandement que tu utiliseras le plus souvent !</p>
                <p><strong>Pourquoi ?</strong> Pour savoir o√π tu en es ! Quels fichiers j'ai modifi√©s ? Qu'est-ce qui sera dans mon prochain commit ? Sur quelle branche je suis ? git status r√©pond √† tout √ßa. Utilise-le constamment !</p>
                <p><strong>Lecture :</strong> Rouge = modifi√© mais pas en staging. Vert = en staging (pr√™t √† commit). "Untracked" = nouveau fichier que Git ne conna√Æt pas encore. "nothing to commit" = tout est propre !</p>
                <code>git status
# On branch main
# Changes not staged: fichiers.txt (en rouge)
# Untracked files: nouveau.txt
git status -s  # Version courte, plus compact</code>
            </div>

            <div class="tag-card">
                <h3>git add &lt;fichier&gt;</h3>
                <p><strong>C'est quoi ?</strong> Ajoute des fichiers √† la zone de staging (index) pour pr√©parer le prochain commit. Les fichiers "stag√©s" seront inclus dans le commit. Tu peux ajouter un fichier, plusieurs, ou tous.</p>
                <p><strong>Pourquoi ?</strong> Git te donne le contr√¥le ! Tu peux choisir EXACTEMENT quels changements mettre dans ton commit. Modifi√© 10 fichiers mais veux commit que 2 ? git add ces 2 fichiers. √áa cr√©e des commits propres et logiques.</p>
                <p><strong>Patterns courants :</strong> git add . = ajoute TOUT (attention !). git add *.js = tous les .js. git add dossier/ = tout un dossier. git add -A = tout, m√™me suppressions.</p>
                <code>git add fichier.txt
git add fichier1.txt fichier2.js
git add .                    # Tout dans le dossier actuel
git add -A                   # TOUT dans le projet
git add *.css                # Tous les fichiers CSS</code>
            </div>

            <div class="tag-card">
                <h3>git commit -m "message"</h3>
                <p><strong>C'est quoi ?</strong> Cr√©e un commit (snapshot) avec tous les fichiers en staging. Le -m permet d'ajouter le message directement dans la commande. Le commit est enregistr√© dans l'historique local avec ton nom, email, date, message.</p>
                <p><strong>Pourquoi ?</strong> Les commits = points de sauvegarde de ton projet ! Chaque commit capture l'√©tat exact de ton code √† un moment donn√©. Tu peux revenir en arri√®re, comparer, partager. C'est la base de Git.</p>
                <p><strong>Message parfait :</strong> Imp√©ratif pr√©sent ("Ajoute login", pas "Ajout√© login"). Court et descriptif. Dit POURQUOI, pas juste quoi. Exemples : "Corrige bug connexion mobile", "Ajoute validation email formulaire".</p>
                <code>git commit -m "Ajoute page d'accueil"
git commit -m "Corrige bug affichage mobile"
git commit -m "Refactor: simplifie fonction authentification"
git commit               # Ouvre l'√©diteur pour message long</code>
            </div>

            <div class="tag-card">
                <h3>git log</h3>
                <p><strong>C'est quoi ?</strong> Affiche l'historique des commits du plus r√©cent au plus ancien : hash du commit, auteur, date, message. C'est le journal de bord de ton projet !</p>
                <p><strong>Pourquoi ?</strong> Pour voir l'histoire de ton projet ! Qui a fait quoi et quand ? Quel commit a introduit un bug ? √Ä quel moment cette feature a √©t√© ajout√©e ? git log raconte tout.</p>
                <p><strong>Options utiles :</strong> --oneline = une ligne par commit (compact). --graph = affiche l'arbre des branches. -n 5 = montre seulement les 5 derniers. --author="nom" = commits d'une personne.</p>
                <code>git log
git log --oneline            # Version compacte
git log --graph --oneline    # Avec arbre des branches
git log -n 5                 # 5 derniers commits
git log --author="Marie"     # Commits de Marie</code>
            </div>

            <div class="tag-card">
                <h3>git diff</h3>
                <p><strong>C'est quoi ?</strong> Montre les diff√©rences entre fichiers : ce qui a chang√© ligne par ligne. Par d√©faut, compare les fichiers modifi√©s avec le dernier commit. Lignes rouges (-) = supprim√©es, vertes (+) = ajout√©es.</p>
                <p><strong>Pourquoi ?</strong> Pour voir EXACTEMENT ce qui a chang√© avant de commit ! "J'ai modifi√© quoi d√©j√† ?" ‚Üí git diff. V√©rifie que tu commit les bonnes choses. Revois ton code avant de le sauvegarder.</p>
                <p><strong>Variantes :</strong> git diff = modifs non stag√©es. git diff --staged = modifs en staging (pr√™tes √† commit). git diff HEAD = toutes les modifs. git diff commit1 commit2 = compare deux commits.</p>
                <code>git diff                     # Modifs non stag√©es
git diff --staged            # Modifs en staging
git diff HEAD                # Toutes les modifs
git diff main feature        # Compare 2 branches
git diff abc123 def456       # Compare 2 commits</code>
            </div>

            <div class="tag-card">
                <h3>git rm &lt;fichier&gt;</h3>
                <p><strong>C'est quoi ?</strong> Supprime un fichier du projet ET de Git en m√™me temps. √âquivalent √† supprimer le fichier + git add pour stager la suppression. La suppression sera dans le prochain commit.</p>
                <p><strong>Pourquoi ?</strong> Plus simple que supprimer manuellement puis git add ! git rm fait les deux d'un coup. Le fichier dispara√Æt de ton disque ET Git arr√™te de le tracker.</p>
                <p><strong>Options :</strong> git rm --cached fichier = retire du Git SANS supprimer du disque (utile pour .gitignore oubli√©). git rm -r dossier/ = supprime un dossier r√©cursivement.</p>
                <code>git rm fichier.txt
git rm --cached secret.env   # Retire de Git, garde sur disque
git rm -r ancien-dossier/    # Supprime dossier complet
git commit -m "Supprime fichiers obsol√®tes"</code>
            </div>

            <div class="tag-card">
                <h3>git mv &lt;ancien&gt; &lt;nouveau&gt;</h3>
                <p><strong>C'est quoi ?</strong> Renomme ou d√©place un fichier dans Git. √âquivalent √† renommer manuellement + git rm ancien + git add nouveau, mais en une seule commande. Git trackera que c'est un renommage, pas une suppression+cr√©ation.</p>
                <p><strong>Pourquoi ?</strong> Git d√©tecte mieux les renommages si tu utilises git mv ! Si tu renommes manuellement, Git peut penser que tu as supprim√© un fichier et cr√©√© un nouveau (historique perdu). git mv pr√©serve l'historique.</p>
                <p><strong>D√©placer aussi :</strong> git mv peut aussi d√©placer dans un autre dossier. C'est utile pour r√©organiser ton projet sans perdre l'historique Git des fichiers.</p>
                <code>git mv ancien-nom.txt nouveau-nom.txt
git mv fichier.js src/fichier.js
git mv old-folder/ new-folder/
git commit -m "Renomme fichiers pour coh√©rence"</code>
            </div>
        </section>

        <section id="branches">
            <h2>üåø Branches</h2>

            <div class="tag-card">
                <h3>git branch</h3>
                <p><strong>C'est quoi ?</strong> Liste toutes les branches locales. La branche actuelle est marqu√©e avec une √©toile (*) et en couleur. Sans argument, c'est juste un affichage, √ßa ne cr√©e rien.</p>
                <p><strong>Pourquoi ?</strong> Pour savoir sur quelle branche tu es et quelles branches existent ! "Je suis sur main ou feature ?" ‚Üí git branch. Rapide et essentiel avant de faire des modifs.</p>
                <p><strong>Options :</strong> git branch -a = toutes les branches (locales + distantes). git branch -r = branches distantes seulement. git branch -v = avec dernier commit de chaque branche.</p>
                <code>git branch
# * main
#   feature-login
#   bugfix-mobile
git branch -a      # Toutes (locales + remote)
git branch -v      # Avec infos commits</code>
            </div>

            <div class="tag-card">
                <h3>git branch &lt;nom-branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Cr√©e une NOUVELLE branche √† partir du commit actuel. La branche est cr√©√©e mais tu n'y es PAS encore (tu restes sur ta branche actuelle). C'est comme cr√©er une copie parall√®le de ton projet.</p>
                <p><strong>Pourquoi ?</strong> Les branches = travailler sur plusieurs choses en parall√®le sans toucher au code principal ! Feature en cours ? Cr√©e une branche. Bug urgent ? Cr√©e une branche. Le main reste propre pendant que tu exp√©rimentes.</p>
                <p><strong>Convention :</strong> Noms descriptifs : feature/login, bugfix/mobile-menu, hotfix/security. √âvite les noms vagues comme "test" ou "nouveau". Tu veux savoir en un coup d'≈ìil ce qu'il y a dans la branche.</p>
                <code>git branch feature-login
git branch bugfix-mobile-menu
git branch hotfix-security
git branch                    # V√©rifie qu'elle existe</code>
            </div>

            <div class="tag-card">
                <h3>git checkout &lt;branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Change de branche active. Tous tes fichiers se transforment pour correspondre √† cette branche ! Si tu as des modifs non commit√©es, Git te bloquera (ou les d√©placera avec toi selon les cas).</p>
                <p><strong>Pourquoi ?</strong> Pour switcher entre diff√©rentes versions de ton code ! Tu √©tais sur main, tu passes √† feature ‚Üí les fichiers changent instantan√©ment pour refl√©ter l'√©tat de feature. Magique mais d√©routant au d√©but !</p>
                <p><strong>S√©curit√© :</strong> Git refuse si tu as des modifs non sauvegard√©es qui seraient √©cras√©es. Commit ou stash avant de checkout ! Sinon : "error: Your local changes would be overwritten".</p>
                <code>git checkout feature-login
git checkout main
git checkout -                # Retourne √† la branche pr√©c√©dente
git status                    # Confirme sur quelle branche tu es</code>
            </div>

            <div class="tag-card">
                <h3>git checkout -b &lt;nom-branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Cr√©e une nouvelle branche ET switch dessus imm√©diatement. C'est le raccourci de git branch + git checkout. Super pratique, c'est ce que tout le monde utilise !</p>
                <p><strong>Pourquoi ?</strong> Gain de temps ! Au lieu de git branch feature puis git checkout feature, tu fais git checkout -b feature. Une commande au lieu de deux. Tu cr√©√©s et commences √† travailler direct.</p>
                <p><strong>Workflow courant :</strong> Tu es sur main, tu veux une nouvelle feature : git checkout -b feature/super-truc ‚Üí tu es imm√©diatement sur la nouvelle branche et peux commencer √† coder !</p>
                <code>git checkout -b feature-login
git checkout -b bugfix-responsive
git checkout -b hotfix/urgent-security
# √âquivalent √† :
# git branch feature-login
# git checkout feature-login</code>
            </div>

            <div class="tag-card">
                <h3>git switch &lt;branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Commande moderne (Git 2.23+) pour changer de branche. Fait la m√™me chose que git checkout mais plus clair (checkout fait trop de choses diff√©rentes). C'est la fa√ßon recommand√©e maintenant.</p>
                <p><strong>Pourquoi ?</strong> git checkout est confusant car il fait plein de trucs : changer de branche, restaurer fichiers, cr√©er branches... git switch est d√©di√© au changement de branche uniquement. Plus simple √† comprendre !</p>
                <p><strong>Cr√©er + switch :</strong> git switch -c nouvelle-branche = cr√©e et switch (comme checkout -b). Les deux commandements (switch et checkout) marchent, utilise celui que tu pr√©f√®res.</p>
                <code>git switch main
git switch feature-login
git switch -c nouvelle-feature    # Cr√©e + switch
git switch -                      # Retour branche pr√©c√©dente</code>
            </div>

            <div class="tag-card">
                <h3>git merge &lt;branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Fusionne une branche dans ta branche actuelle. Les commits de la branche cible sont int√©gr√©s. Par exemple, sur main, git merge feature-login int√®gre tous les commits de feature-login dans main.</p>
                <p><strong>Pourquoi ?</strong> Pour ramener tes modifications dans la branche principale ! Feature termin√©e sur ta branche ? Retourne sur main et merge ta branche feature. Ton travail rejoint le code principal.</p>
                <p><strong>Conflits :</strong> Si Git ne peut pas merger automatiquement (m√™me ligne modifi√©e diff√©remment), il te demande de r√©soudre manuellement. Ouvre les fichiers en conflit, choisis quelle version garder, puis git add + git commit.</p>
                <code>git checkout main
git merge feature-login      # Int√®gre feature-login dans main
# Si conflit :
# R√©sous manuellement dans les fichiers
git add .
git commit -m "Merge feature-login"</code>
            </div>

            <div class="tag-card">
                <h3>git branch -d &lt;branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Supprime une branche locale. Le -d (delete) est "s√ªr" : refuse si la branche a des commits non merg√©s (protection contre perte de travail). Pour forcer : -D majuscule.</p>
                <p><strong>Pourquoi ?</strong> Nettoyer les branches termin√©es ! Feature merg√©e dans main ? Supprime la branche feature, plus besoin. Garde ton projet propre, √©vite d'accumuler 50 branches obsol√®tes.</p>
                <p><strong>S√©curit√© :</strong> -d = s√ªr, refuse si non merg√©e. -D = force, supprime m√™me si non merg√©e (attention, perte de commits !). Toujours -d d'abord, -D seulement si tu es S√õR de vouloir perdre le travail.</p>
                <code>git branch -d feature-login     # S√ªr
git branch -D branche-test        # Force (attention !)
git branch -d old-feature
# error: not fully merged ‚Üí utilise -D si vraiment s√ªr</code>
            </div>

            <div class="tag-card">
                <h3>git branch -m &lt;nouveau-nom&gt;</h3>
                <p><strong>C'est quoi ?</strong> Renomme la branche actuelle. Le -m (move) change le nom sans toucher aux commits. Tu peux aussi git branch -m ancien nouveau pour renommer une autre branche.</p>
                <p><strong>Pourquoi ?</strong> Corriger une faute de frappe ou am√©liorer le nom ! Tu as cr√©√© "featur-login" (typo) ? git branch -m feature-login. Ou tu veux un nom plus clair pour une branche existante.</p>
                <p><strong>Attention remote :</strong> Si la branche existe sur GitHub, renommer localement ne suffit pas. Il faut aussi push la nouvelle, supprimer l'ancienne sur remote : git push origin :ancien nouveau.</p>
                <code>git branch -m nouveau-nom              # Renomme branche actuelle
git branch -m ancien-nom nouveau-nom    # Renomme autre branche
git branch -m featur-login feature-login  # Corrige typo</code>
            </div>
        </section>

        <section id="remote">
            <h2>‚òÅÔ∏è Remote & Synchronisation</h2>

            <div class="tag-card">
                <h3>git remote add origin &lt;url&gt;</h3>
                <p><strong>C'est quoi ?</strong> Connecte ton d√©p√¥t local √† un d√©p√¥t distant (GitHub, GitLab). "origin" est le nom conventionnel du remote principal. L'URL peut √™tre HTTPS ou SSH.</p>
                <p><strong>Pourquoi ?</strong> Pour pousser ton code sur GitHub ! Tu as fait git init localement ? Maintenant relie-le √† un repo GitHub avec git remote add. Ensuite tu pourras push/pull.</p>
                <p><strong>Une seule fois :</strong> git clone configure origin automatiquement. git remote add n'est n√©cessaire que si tu as fait git init (projet cr√©√© localement d'abord). V√©rifie avec git remote -v.</p>
                <code>git remote add origin https://github.com/user/projet.git
git remote add origin git@github.com:user/projet.git
git remote -v                # V√©rifie que origin est configur√©</code>
            </div>

            <div class="tag-card">
                <h3>git remote -v</h3>
                <p><strong>C'est quoi ?</strong> Liste tous les remotes configur√©s avec leurs URLs. Le -v (verbose) montre les URLs pour fetch (t√©l√©charger) et push (envoyer). G√©n√©ralement tu as juste "origin".</p>
                <p><strong>Pourquoi ?</strong> Pour v√©rifier vers o√π tu push/pull ! "Mon push va o√π ?" ‚Üí git remote -v. Utile pour confirmer que origin pointe vers le bon repo GitHub, ou d√©couvrir les remotes existants.</p>
                <p><strong>Lecture :</strong> origin suivi de 2 lignes : (fetch) pour pull, (push) pour push. Si les URLs sont identiques (cas normal), fetch et push vont au m√™me endroit.</p>
                <code>git remote -v
# origin  https://github.com/user/projet.git (fetch)
# origin  https://github.com/user/projet.git (push)
git remote    # Juste les noms (sans URLs)</code>
            </div>

            <div class="tag-card">
                <h3>git push origin &lt;branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Envoie tes commits locaux vers le d√©p√¥t distant (GitHub). origin = nom du remote, branche = quelle branche envoyer. Tes commits deviennent visibles sur GitHub pour ton √©quipe.</p>
                <p><strong>Pourquoi ?</strong> Sauvegarder ton code sur GitHub et partager avec l'√©quipe ! Commits faits localement ? Ils restent sur ton PC. git push les envoie sur GitHub. Backup + collaboration.</p>
                <p><strong>Premi√®re fois :</strong> git push -u origin main configure le "upstream" (lien branche locale ‚Üî distante). Apr√®s, juste git push suffit. -u = --set-upstream, √† faire une fois par branche.</p>
                <code>git push origin main
git push origin feature-login
git push -u origin nouvelle-branche   # Premi√®re fois
git push                               # Apr√®s avoir fait -u</code>
            </div>

            <div class="tag-card">
                <h3>git pull</h3>
                <p><strong>C'est quoi ?</strong> T√©l√©charge les nouveaux commits du remote ET les merge dans ta branche actuelle. C'est git fetch + git merge en une seule commande. Synchronise ton code local avec GitHub.</p>
                <p><strong>Pourquoi ?</strong> R√©cup√©rer le travail des autres ! Ton coll√®gue a push sur GitHub ? git pull pour int√©grer ses modifs dans ton code local. Garde ton projet √† jour avec le remote.</p>
                <p><strong>Conflit possible :</strong> Si toi ET quelqu'un d'autre avez modifi√© la m√™me ligne, git pull cr√©era un conflit de merge. R√©sous-le manuellement, puis git add + git commit.</p>
                <code>git pull
git pull origin main
git pull origin feature-login
# Si conflit : r√©sous dans fichiers, puis
git add .
git commit -m "R√©sout conflits merge"</code>
            </div>

            <div class="tag-card">
                <h3>git fetch</h3>
                <p><strong>C'est quoi ?</strong> T√©l√©charge les nouveaux commits du remote SANS les merger. Met √† jour tes branches remote/origin/... mais ne touche PAS √† tes branches locales. C'est "voir ce qu'il y a de nouveau" sans appliquer.</p>
                <p><strong>Pourquoi ?</strong> V√©rifier ce qui a chang√© sur GitHub sans risque ! git fetch = regarder. git pull = regarder + appliquer. Fetch d'abord, regarde les diff√©rences (git log origin/main), puis d√©cide de merge ou non.</p>
                <p><strong>Workflow s√ªr :</strong> git fetch ‚Üí git diff origin/main (voir diff√©rences) ‚Üí git merge origin/main (si ok) ou git pull direct si confiant. Fetch est plus prudent que pull.</p>
                <code>git fetch
git fetch origin
git log origin/main       # Voir commits t√©l√©charg√©s
git diff origin/main      # Voir diff√©rences
git merge origin/main     # Appliquer si ok</code>
            </div>

            <div class="tag-card">
                <h3>git push --force (ou -f)</h3>
                <p><strong>C'est quoi ?</strong> Force le push m√™me si √ßa √©crase l'historique distant. DANGEREUX ! Remplace compl√®tement la branche distante par ta version locale, m√™me si elle a des commits que tu n'as pas.</p>
                <p><strong>Pourquoi ?</strong> Apr√®s un rebase ou un commit --amend qui r√©√©crit l'historique. Git refuse le push normal (historiques divergents) ‚Üí --force √©crase le remote. Utilise UNIQUEMENT sur TES branches, JAMAIS sur main/develop partag√©s !</p>
                <p><strong>Alternative safer :</strong> --force-with-lease refuse si quelqu'un a push entre temps (protection suppl√©mentaire). Pr√©f√®re √ßa √† --force brut. Mais s√©rieusement, fais gaffe, tu peux perdre le travail des autres.</p>
                <code>git push --force origin feature     # DANGEREUX !
git push --force-with-lease origin feature  # Safer
git push -f origin ma-branche-solo          # OK si branche perso
# JAMAIS sur main/develop partag√©s !</code>
            </div>

            <div class="tag-card">
                <h3>git push --delete origin &lt;branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> Supprime une branche sur le remote (GitHub). La branche locale reste intacte, seule la version GitHub est supprim√©e. Syntaxe alternative : git push origin :branche.</p>
                <p><strong>Pourquoi ?</strong> Nettoyer GitHub apr√®s un merge ! Feature merg√©e dans main sur GitHub (via Pull Request) ? Supprime la branche feature devenue inutile. Garde GitHub propre.</p>
                <p><strong>Workflow :</strong> Branche locale supprim√©e (git branch -d) + branche remote supprim√©e (git push --delete) = nettoyage complet. Ou laisse GitHub supprimer auto apr√®s merge de PR.</p>
                <code>git push --delete origin feature-login
git push origin :feature-login     # Syntaxe alternative
git branch -d feature-login        # Supprime aussi en local</code>
            </div>

            <div class="tag-card">
                <h3>git clone --depth 1 &lt;url&gt;</h3>
                <p><strong>C'est quoi ?</strong> Clone seulement le dernier commit (historique r√©duit), sans tout l'historique du projet. Beaucoup plus rapide et l√©ger ! Appel√© "shallow clone".</p>
                <p><strong>Pourquoi ?</strong> Pour les gros projets avec des ann√©es d'historique ! Linux kernel = 3GB avec historique complet, 200MB avec --depth 1. Tu veux juste le code actuel sans l'historique ? Shallow clone.</p>
                <p><strong>Limitation :</strong> Tu ne peux pas voir l'historique complet, revenir loin en arri√®re, ou facilement contribuer. Parfait pour d√©ploiements, CI/CD, ou juste regarder le code. Pas pour d√©veloppement actif.</p>
                <code>git clone --depth 1 https://github.com/user/gros-projet.git
git clone --depth 5 &lt;url&gt;   # 5 derniers commits
# Pour r√©cup√©rer l'historique apr√®s :
git fetch --unshallow</code>
            </div>
        </section>

        <section id="history">
            <h2>üìú Historique & Inspection</h2>

            <div class="tag-card">
                <h3>git log --oneline</h3>
                <p><strong>C'est quoi ?</strong> Affiche l'historique des commits en format compact : une ligne par commit avec hash court + message. Beaucoup plus lisible que git log normal quand il y a beaucoup de commits.</p>
                <p><strong>Pourquoi ?</strong> Vue d'ensemble rapide ! git log normal est verbeux (auteur, date, message long). --oneline = juste l'essentiel. Tu peux voir 50 commits en un √©cran.</p>
                <p><strong>Combos :</strong> --oneline --graph = arbre des branches + compact. --oneline -n 10 = 10 derniers seulement. --oneline --all = toutes les branches. Tr√®s utilis√© au quotidien !</p>
                <code>git log --oneline
# a1b2c3d Ajoute page login
# e4f5g6h Corrige bug mobile
git log --oneline --graph
git log --oneline -n 10</code>
            </div>

            <div class="tag-card">
                <h3>git log --graph</h3>
                <p><strong>C'est quoi ?</strong> Affiche l'historique avec un graphique ASCII des branches et merges. Montre visuellement comment les branches divergent et se rejoignent. Parfait pour comprendre l'arbre des commits.</p>
                <p><strong>Pourquoi ?</strong> Voir la structure du projet ! Combien de branches ? Quand ont-elles merg√© ? --graph dessine l'arbre avec des lignes et √©toiles. Combine avec --oneline pour version lisible.</p>
                <p><strong>Version ultimate :</strong> git log --oneline --graph --all --decorate = vue compl√®te : toutes branches, graphique, tags, compact. Cr√©e un alias pour √ßa (c'est long √† taper) !</p>
                <code>git log --graph
git log --oneline --graph --all
git log --oneline --graph --decorate --all
# Alias pratique :
git config --global alias.tree "log --oneline --graph --all"
git tree</code>
            </div>

            <div class="tag-card">
                <h3>git show &lt;commit&gt;</h3>
                <p><strong>C'est quoi ?</strong> Affiche les d√©tails d'un commit sp√©cifique : auteur, date, message, et DIFF complet (tout ce qui a chang√©). C'est comme git log + git diff pour un commit pr√©cis.</p>
                <p><strong>Pourquoi ?</strong> Inspecter un commit ! "Qu'est-ce qui a chang√© dans ce commit ?" ‚Üí git show abc123. Tr√®s utile pour comprendre un bug, revivre les modifs, ou v√©rifier ce qu'un coll√®gue a fait.</p>
                <p><strong>Raccourcis :</strong> git show = dernier commit (HEAD). git show HEAD~1 = avant-dernier. git show HEAD~3 = 3 commits avant. git show branch:fichier.txt = contenu d'un fichier sur une branche.</p>
                <code>git show abc123
git show HEAD           # Dernier commit
git show HEAD~2         # 2 commits avant
git show main:file.txt  # Fichier sur branche main</code>
            </div>

            <div class="tag-card">
                <h3>git blame &lt;fichier&gt;</h3>
                <p><strong>C'est quoi ?</strong> Montre qui a modifi√© chaque ligne d'un fichier, quand, et dans quel commit. Chaque ligne = auteur + date + hash commit + contenu. Parfait pour trouver l'origine d'un changement !</p>
                <p><strong>Pourquoi ?</strong> "Qui a √©crit cette ligne ?" ‚Üí git blame. Debugging : trouver qui a introduit un bug. Historique : comprendre pourquoi ce code existe. Pas pour "bl√¢mer", juste pour tracer l'origine.</p>
                <p><strong>GitHub :</strong> Sur GitHub, le bouton "Blame" dans l'interface fait pareil mais plus joli. En CLI, git blame -L 10,20 fichier.txt = lignes 10 √† 20 seulement.</p>
                <code>git blame fichier.js
git blame -L 50,100 app.js    # Lignes 50-100 seulement
git blame -e fichier.txt       # Affiche emails des auteurs
git blame --since="1 month ago" code.py</code>
            </div>

            <div class="tag-card">
                <h3>git shortlog</h3>
                <p><strong>C'est quoi ?</strong> R√©sum√© des commits group√©s par auteur. Affiche combien de commits chaque personne a fait + leurs messages. Statistiques de contribution !</p>
                <p><strong>Pourquoi ?</strong> Voir qui contribue au projet ! Combien de commits par d√©veloppeur ? Qui est le plus actif ? G√©n√®re des stats automatiquement. Utile pour rapports, cr√©dits, comprendre l'√©quipe.</p>
                <p><strong>Options :</strong> -s = seulement nombres (pas les messages). -n = tri par nombre de commits. -e = affiche emails. Combine : git shortlog -sn = classement des contributeurs.</p>
                <code>git shortlog
git shortlog -sn          # Classement par nb commits
git shortlog -sne         # Avec emails
git shortlog --since="1 month"  # Dernier mois</code>
            </div>

            <div class="tag-card">
                <h3>git log --since / --until</h3>
                <p><strong>C'est quoi ?</strong> Filtre l'historique par date. --since = depuis quand, --until = jusqu'√† quand. Accepte dates absolues (2024-01-01) ou relatives (1 week ago, 2 months ago).</p>
                <p><strong>Pourquoi ?</strong> Voir ce qui s'est pass√© dans une p√©riode ! "Qu'est-ce qui a chang√© la semaine derni√®re ?" ‚Üí git log --since="1 week ago". Rapport mensuel ? --since="1 month ago".</p>
                <p><strong>Formats :</strong> "2024-01-15", "1 week ago", "yesterday", "2 months ago", "2024-01-01..2024-01-31". Tr√®s flexible ! Combine avec --author ou --grep pour filtres multiples.</p>
                <code>git log --since="2 weeks ago"
git log --since="2024-01-01" --until="2024-01-31"
git log --since="yesterday"
git log --since="1 month ago" --author="Marie"</code>
            </div>

            <div class="tag-card">
                <h3>git log --grep "&lt;pattern&gt;"</h3>
                <p><strong>C'est quoi ?</strong> Cherche dans les messages de commit. Affiche seulement les commits dont le message contient le pattern. Case-insensitive avec -i. Regex support√© !</p>
                <p><strong>Pourquoi ?</strong> Trouver des commits sp√©cifiques ! "Quel commit a corrig√© le bug mobile ?" ‚Üí git log --grep="mobile". Chercher toutes les features, bugfixes, ou mentions d'un ticket.</p>
                <p><strong>Patterns utiles :</strong> git log --grep="fix" = tous les bugfixes. git log --grep="feature" = features. git log --grep="#123" = commits li√©s au ticket #123. Combine avec --since pour p√©riode.</p>
                <code>git log --grep="bug"
git log --grep="fix" -i          # Case-insensitive
git log --grep="feature" --oneline
git log --grep="#123"             # Num√©ro de ticket</code>
            </div>

            <div class="tag-card">
                <h3>git log --author="&lt;nom&gt;"</h3>
                <p><strong>C'est quoi ?</strong> Filtre les commits par auteur. Affiche seulement les commits d'une personne sp√©cifique. Pas besoin du nom complet, une partie suffit.</p>
                <p><strong>Pourquoi ?</strong> Voir ce qu'une personne a fait ! "Qu'est-ce que Marie a cod√© ?" ‚Üí git log --author="Marie". Revue de code, statistiques perso, comprendre les contributions.</p>
                <p><strong>Patterns :</strong> git log --author="Marie" match "Marie Dupont", "marie@exemple.com", tout ce qui contient "Marie". Combine avec --since pour "commits de Marie ce mois-ci".</p>
                <code>git log --author="Marie"
git log --author="marie@exemple.com"
git log --author="Marie" --since="1 month ago"
git log --author="Marie" --oneline</code>
            </div>
        </section>

        <section id="advanced">
            <h2>‚ö° Commandes Avanc√©es</h2>

            <div class="tag-card">
                <h3>git stash</h3>
                <p><strong>C'est quoi ?</strong> Sauvegarde temporairement tes modifications non commit√©es dans une "cachette" et nettoie ton working directory. Les modifs disparaissent (mais sont stock√©es). Tu peux les r√©cup√©rer plus tard avec git stash pop.</p>
                <p><strong>Pourquoi ?</strong> Changer de branche sans commit ! Tu codes une feature, urgence sur main : git stash (sauvegarde), git checkout main (r√©sous urgence), git checkout feature, git stash pop (r√©cup√®re modifs). Temporaire parfait !</p>
                <p><strong>Use cases :</strong> Switch branches sans commit. Pull alors que tu as des modifs. Tester quelque chose puis revenir. Stash = tiroir temporaire pour tes modifs.</p>
                <code>git stash                  # Sauvegarde modifs
git stash list              # Liste stashs
git stash pop               # R√©cup√®re + supprime stash
git stash apply             # R√©cup√®re sans supprimer</code>
            </div>

            <div class="tag-card">
                <h3>git stash pop</h3>
                <p><strong>C'est quoi ?</strong> R√©cup√®re les modifications du dernier stash ET supprime ce stash de la pile. C'est l'inverse de git stash : remet tes modifs dans le working directory.</p>
                <p><strong>Pourquoi ?</strong> Reprendre l√† o√π tu t'√©tais arr√™t√© ! Tu as stash avant de changer de branche ? Reviens sur ta branche, git stash pop, et tes modifs r√©apparaissent. Comme un Ctrl+Z invers√©.</p>
                <p><strong>Conflit possible :</strong> Si tu as modifi√© les m√™mes lignes entre le stash et maintenant, Git cr√©era un conflit. R√©sous-le, puis supprime le stash manuellement (git stash drop) si besoin.</p>
                <code>git stash pop
# Si conflit : r√©sous manuellement
git stash pop stash@{1}     # Pop un stash sp√©cifique
git stash apply             # Applique sans supprimer</code>
            </div>

            <div class="tag-card">
                <h3>git tag &lt;nom&gt;</h3>
                <p><strong>C'est quoi ?</strong> Cr√©e un tag (√©tiquette) sur le commit actuel. Les tags marquent des points importants : versions, releases. Exemple : v1.0, v2.1.3. Contrairement aux branches, les tags ne bougent jamais.</p>
                <p><strong>Pourquoi ?</strong> Marquer les releases ! v1.0.0 sortie ? git tag v1.0.0. Tu peux checkout ce tag plus tard pour revenir exactement √† cette version. GitHub cr√©e des releases automatiquement √† partir des tags.</p>
                <p><strong>Types :</strong> Lightweight (juste un nom) : git tag v1.0. Annotated (avec message) : git tag -a v1.0 -m "Version 1.0". Annotated est recommand√© pour releases officielles.</p>
                <code>git tag v1.0.0
git tag -a v2.0.0 -m "Version 2.0 - Refonte UI"
git tag                     # Liste tous les tags
git push origin v1.0.0      # Push tag sur GitHub</code>
            </div>

            <div class="tag-card">
                <h3>git rebase &lt;branche&gt;</h3>
                <p><strong>C'est quoi ?</strong> R√©applique tes commits au-dessus d'une autre branche. Alternative √† merge qui garde un historique lin√©aire. Au lieu de cr√©er un commit de merge, rebase r√©√©crit l'historique.</p>
                <p><strong>Pourquoi ?</strong> Historique propre et lin√©aire ! Sur feature, git rebase main met √† jour feature avec les derniers commits de main SANS cr√©er de commit de merge. L'historique reste une ligne droite, plus facile √† lire.</p>
                <p><strong>DANGER :</strong> R√©√©crit l'historique = change les hash des commits. JAMAIS rebase des commits d√©j√† push√©s sur une branche partag√©e (main, develop) ! Seulement sur TES branches perso avant de merge.</p>
                <code>git checkout feature
git rebase main             # Met feature √† jour avec main
# Si conflit : r√©sous, puis
git add .
git rebase --continue
git rebase --abort          # Annule le rebase</code>
            </div>

            <div class="tag-card">
                <h3>git cherry-pick &lt;commit&gt;</h3>
                <p><strong>C'est quoi ?</strong> Copie un commit sp√©cifique d'une branche vers ta branche actuelle. "Pioche" juste UN commit sans merger toute la branche. Le commit est dupliqu√© avec un nouveau hash.</p>
                <p><strong>Pourquoi ?</strong> R√©cup√©rer un bugfix d'une branche ! Branche feature a un commit qui corrige un bug, mais feature n'est pas pr√™te √† merge ? Cherry-pick juste ce commit dans main. Tr√®s utile pour hotfixes.</p>
                <p><strong>Use case :</strong> Feature-branch a 10 commits dont 1 bugfix urgent. Au lieu de merger les 10, cherry-pick juste le bugfix dans main. Pratique mais peut cr√©er de la confusion (commit dupliqu√©).</p>
                <code>git checkout main
git cherry-pick abc123      # Copie commit abc123 dans main
git cherry-pick abc123 def456  # Plusieurs commits
# Si conflit : r√©sous, puis
git cherry-pick --continue</code>
            </div>

            <div class="tag-card">
                <h3>git bisect</h3>
                <p><strong>C'est quoi ?</strong> Outil de recherche binaire pour trouver quel commit a introduit un bug. Git teste automatiquement les commits (bon/mauvais) par dichotomie jusqu'√† trouver le commit coupable. Debugging puissant !</p>
                <p><strong>Pourquoi ?</strong> Trouver l'origine d'un bug myst√©rieux ! "Le code marchait avant, maintenant cass√©, mais quand ?" ‚Üí bisect teste automatiquement. En quelques √©tapes, trouve le commit exact qui a introduit le bug.</p>
                <p><strong>Workflow :</strong> git bisect start ‚Üí git bisect bad (actuel est cass√©) ‚Üí git bisect good v1.0 (v1.0 marchait) ‚Üí Git checkout un commit entre les deux ‚Üí tu testes ‚Üí git bisect good/bad ‚Üí r√©p√®te jusqu'√† trouver.</p>
                <code>git bisect start
git bisect bad              # Actuel est bugg√©
git bisect good v1.5.0      # v1.5.0 marchait
# Git checkout un commit
# Teste ton code
git bisect good             # ou bad selon r√©sultat
# R√©p√®te jusqu'√† trouver le commit coupable
git bisect reset            # Termine</code>
            </div>

            <div class="tag-card">
                <h3>git reflog</h3>
                <p><strong>C'est quoi ?</strong> Log de TOUTES tes actions Git locales : commits, checkouts, resets, rebases, etc. C'est l'historique de tes mouvements dans Git. M√™me les commits "perdus" sont l√† !</p>
                <p><strong>Pourquoi ?</strong> Sauvetage d'urgence ! Tu as fait un git reset --hard et perdu des commits ? reflog les liste encore. Tu peux les r√©cup√©rer en checkoutant leur hash. C'est le filet de s√©curit√© ultime.</p>
                <p><strong>R√©cup√©ration :</strong> git reflog ‚Üí trouve hash du commit perdu ‚Üí git checkout abc123 ou git cherry-pick abc123 ‚Üí sauv√© ! Reflog garde l'historique ~90 jours.</p>
                <code>git reflog
# abc123 HEAD@{0}: commit: Message
# def456 HEAD@{1}: reset: moving to HEAD~1
git checkout abc123         # R√©cup√®re commit perdu
git cherry-pick def456      # Ou copy le commit</code>
            </div>

            <div class="tag-card">
                <h3>git clean -fd</h3>
                <p><strong>C'est quoi ?</strong> Supprime tous les fichiers non track√©s (pas dans Git) du working directory. -f = force (obligatoire), -d = dossiers aussi. IRR√âVERSIBLE, fichiers supprim√©s d√©finitivement !</p>
                <p><strong>Pourquoi ?</strong> Nettoyer le projet des fichiers de build, logs, caches g√©n√©r√©s. Repartir propre apr√®s des tests. Attention : supprime VRAIMENT, pas de corbeille ! V√©rifie d'abord avec git clean -n (dry-run).</p>
                <p><strong>S√©curit√© :</strong> TOUJOURS git clean -n d'abord (montre ce qui SERAIT supprim√©). V√©rifie la liste. Si ok : git clean -fd. Les fichiers dans .gitignore sont ignor√©s par d√©faut (safe).</p>
                <code>git clean -n              # Dry-run, montre ce qui serait supprim√©
git clean -fd             # Supprime fichiers + dossiers non track√©s
git clean -fdx            # Supprime m√™me les fichiers .gitignore
# ATTENTION : irr√©versible !</code>
            </div>
        </section>

        <section id="undo">
            <h2>‚Ü©Ô∏è Annuler & Corriger</h2>

            <div class="tag-card">
                <h3>git restore &lt;fichier&gt;</h3>
                <p><strong>C'est quoi ?</strong> Annule les modifications non commit√©es d'un fichier. Restaure le fichier √† l'√©tat du dernier commit. Commande moderne (Git 2.23+), remplace git checkout -- fichier. Les modifs sont PERDUES !</p>
                <p><strong>Pourquoi ?</strong> "Oups j'ai cass√© ce fichier, je veux revenir en arri√®re !" ‚Üí git restore fichier.txt. Annule tes tests rat√©s, erreurs, exp√©rimentations. Repart du dernier commit propre.</p>
                <p><strong>Variantes :</strong> git restore . = restore TOUT. git restore --staged fichier = retire du staging (unstage) sans supprimer modifs. git restore --source=abc123 fichier = restore depuis un commit sp√©cifique.</p>
                <code>git restore fichier.txt
git restore .                     # Restore tout
git restore --staged fichier.txt  # Unstage (garde modifs)
git restore --source=HEAD~1 file  # Depuis commit pr√©c√©dent</code>
            </div>

            <div class="tag-card">
                <h3>git reset HEAD~1</h3>
                <p><strong>C'est quoi ?</strong> Annule le(s) dernier(s) commit(s) en d√©pla√ßant HEAD. HEAD~1 = 1 commit avant. Les modifs du commit restent dans le working directory (pas perdues). Tu peux recommiter diff√©remment.</p>
                <p><strong>Pourquoi ?</strong> Corriger un commit rat√© ! Message de commit nul ? Oubli√© un fichier ? git reset HEAD~1, corrige, re-commit. Les fichiers restent modifi√©s, seul le commit est annul√©.</p>
                <p><strong>Modes :</strong> --soft (garde staging), --mixed (d√©faut, unstage), --hard (SUPPRIME modifs, danger !). 99% du temps : reset sans option (mixed) ou --soft. JAMAIS --hard sauf si S√õR.</p>
                <code>git reset HEAD~1            # Annule dernier commit, garde modifs
git reset HEAD~3            # Annule 3 derniers
git reset --soft HEAD~1     # Annule mais garde staging
git reset --hard HEAD~1     # DANGER : supprime modifs !</code>
            </div>

            <div class="tag-card">
                <h3>git reset --hard</h3>
                <p><strong>C'est quoi ?</strong> Reset BRUTAL qui supprime toutes les modifications ET d√©place HEAD. Remet le projet exactement √† l'√©tat du commit cible. Working directory + staging = nettoy√©s. IRR√âVERSIBLE (enfin presque, reflog peut sauver).</p>
                <p><strong>Pourquoi ?</strong> Recommencer √† z√©ro depuis un commit propre. Tout est cass√© ? git reset --hard HEAD ‚Üí retour au dernier commit. Exp√©rimentation rat√©e ? Reset hard et repars de z√©ro.</p>
                <p><strong>DANGER EXTR√äME :</strong> Toutes les modifs non commit√©es sont PERDUES d√©finitivement ! Utilise seulement si tu es ABSOLUMENT S√õR. Double-check avec git status avant. R√©cup√©ration possible avec git reflog mais compliqu√©.</p>
                <code>git reset --hard HEAD        # Annule toutes modifs non commit√©es
git reset --hard HEAD~1      # Retour 1 commit + supprime modifs
git reset --hard origin/main # Identique au remote
# ATTENTION : perte de donn√©es !</code>
            </div>

            <div class="tag-card">
                <h3>git revert &lt;commit&gt;</h3>
                <p><strong>C'est quoi ?</strong> Annule un commit en cr√©ant un NOUVEAU commit qui fait l'inverse. Contrairement √† reset, n'efface PAS l'historique, l'inverse juste. Safe pour branches partag√©es !</p>
                <p><strong>Pourquoi ?</strong> Annuler un commit d√©j√† push√© ! Reset r√©√©crit l'historique (dangereux sur branches partag√©es). Revert ajoute un commit "anti-commit" qui annule les changements. Historique intact, annulation visible.</p>
                <p><strong>Quand l'utiliser :</strong> Commit d√©j√† sur main/develop partag√© ? Revert. Commit seulement local sur ta branche perso ? Reset est ok. Revert = safe, reset = dangereux sur remote.</p>
                <code>git revert abc123           # Annule commit abc123
git revert HEAD              # Annule dernier commit
git revert HEAD~3            # Annule 3e commit avant
# Cr√©e un nouveau commit "Revert 'message original'"</code>
            </div>

            <div class="tag-card">
                <h3>git commit --amend</h3>
                <p><strong>C'est quoi ?</strong> Modifie le dernier commit : change le message et/ou ajoute des fichiers oubli√©s. Le commit est r√©√©crit avec un nouveau hash. Pratique pour corriger des petites erreurs juste apr√®s un commit.</p>
                <p><strong>Pourquoi ?</strong> Corriger un commit r√©cent ! Typo dans le message ? --amend. Oubli√© un fichier ? git add + --amend. √âvite d'avoir un commit "oups correction" dans l'historique.</p>
                <p><strong>ATTENTION :</strong> R√©√©crit l'historique (nouveau hash) ! OK si pas encore push√©. Si d√©j√† push, il faudra force push (dangereux). Ne jamais amend un commit sur branche partag√©e avec l'√©quipe !</p>
                <code>git commit --amend -m "Nouveau message"
# Oubli√© un fichier :
git add fichier-oublie.txt
git commit --amend --no-edit   # Ajoute au commit sans changer message
git commit --amend             # Change message (ouvre √©diteur)</code>
            </div>

            <div class="tag-card">
                <h3>git restore --staged &lt;fichier&gt;</h3>
                <p><strong>C'est quoi ?</strong> Retire un fichier du staging (unstage) sans supprimer les modifications. Le fichier reste modifi√© mais n'est plus dans le prochain commit. Inverse de git add.</p>
                <p><strong>Pourquoi ?</strong> "Oups j'ai add le mauvais fichier !" ‚Üí git restore --staged fichier. Ou tu veux commit en 2 fois : unstage certains fichiers, commit le reste, puis re-add et commit s√©par√©ment.</p>
                <p><strong>Ancienne commande :</strong> Avant Git 2.23, c'√©tait git reset HEAD fichier. restore --staged est plus clair. Les deux marchent, restore est recommand√© maintenant.</p>
                <code>git restore --staged fichier.txt
git restore --staged .          # Unstage tout
# √âquivalent ancien :
git reset HEAD fichier.txt</code>
            </div>

            <div class="tag-card">
                <h3>git checkout &lt;commit&gt; -- &lt;fichier&gt;</h3>
                <p><strong>C'est quoi ?</strong> Restaure un fichier √† son √©tat dans un commit sp√©cifique. R√©cup√®re une ancienne version d'un fichier sans changer de branche ni toucher aux autres fichiers.</p>
                <p><strong>Pourquoi ?</strong> "Ce fichier marchait avant, je veux l'ancienne version !" ‚Üí checkout depuis un vieux commit. R√©cup√®re une fonction supprim√©e, une config qui marchait, un fichier accidentellement cass√©.</p>
                <p><strong>Alternative moderne :</strong> git restore --source=commit fichier fait pareil (plus clair). checkout est l'ancienne fa√ßon. Les deux marchent, restore est recommand√©.</p>
                <code>git checkout abc123 -- fichier.txt
git checkout HEAD~3 -- config.json
# Version moderne :
git restore --source=abc123 fichier.txt</code>
            </div>

            <div class="tag-card">
                <h3>git reset HEAD</h3>
                <p><strong>C'est quoi ?</strong> Unstage tous les fichiers (retire du staging). √âquivalent √† git restore --staged . mais ancienne syntaxe. Les modifs restent, juste pas en staging.</p>
                <p><strong>Pourquoi ?</strong> "J'ai add trop de trucs, je veux recommencer la s√©lection" ‚Üí git reset HEAD. Repart de z√©ro pour le staging, choisis mieux quoi commiter.</p>
                <p><strong>Moderne vs ancien :</strong> git reset HEAD fichier = ancien. git restore --staged fichier = moderne. Les deux font pareil, restore est plus clair pour les d√©butants.</p>
                <code>git reset HEAD              # Unstage tout
git reset HEAD fichier.txt   # Unstage un fichier
# Version moderne √©quivalente :
git restore --staged .</code>
            </div>
        </section>
    </main>

    <footer>
        <p>üîÄ Guide Git cr√©√© pour ma√Ætriser le versioning comme un pro !</p>
        <p>
            <a href="html-guide.html">‚Üê Guide HTML</a> |
            <a href="css-guide.html">Guide CSS</a> |
            <a href="js-guide.html">Guide JavaScript</a> |
            <a href="bootstrap-guide.html">Guide Bootstrap</a>
        </p>
    </footer>

    <script>
        const searchInput = document.getElementById('searchInput');
        const allCards = document.querySelectorAll('.tag-card');

        searchInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase().trim();

            // R√©initialiser tous les backgrounds
            allCards.forEach(card => {
                card.style.backgroundColor = '';
            });

            if (searchTerm === '') return;

            // Chercher dans les h3
            let firstMatch = null;
            allCards.forEach(card => {
                const h3 = card.querySelector('h3');
                if (h3 && h3.textContent.toLowerCase().includes(searchTerm)) {
                    card.style.backgroundColor = '#fff3cd';
                    if (!firstMatch) {
                        firstMatch = card;
                    }
                }
            });

            // Scroller vers le premier r√©sultat
            if (firstMatch) {
                firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        });
    </script>
</body>
</html>
