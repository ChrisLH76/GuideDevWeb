<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guide JavaScript & DOM</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <aside>
        <h1>‚ö° Le Guide JavaScript & DOM</h1>
        <p class="subtitle">Toutes les commandes JavaScript pour manipuler le DOM !</p>
        <p>
            <a href="html-guide.html">Guide HTML</a>
            <a href="css-guide.html">Guide CSS</a>
            <a href="bootstrap-guide.html">Guide Bootstrap</a>
            <a href="git-guide.html">Guide Git</a>
        </p>
    </aside>

    <nav>
        <div class="nav-logo">
            <svg viewBox="0 0 630 630" xmlns="http://www.w3.org/2000/svg">
                <rect width="630" height="630" fill="#f7df1e"/>
                <path d="m423.2 492.19c12.69 20.72 29.2 35.95 58.4 35.95 24.53 0 40.2-12.26 40.2-29.2 0-20.3-16.1-27.49-43.1-39.3l-14.8-6.35c-42.72-18.2-71.1-41-71.1-89.2 0-44.4 33.83-78.2 86.7-78.2 37.64 0 64.7 13.1 84.2 47.4l-46.1 29.6c-10.15-18.2-21.1-25.37-38.1-25.37-17.34 0-28.33 11-28.33 25.37 0 17.76 11 24.95 36.4 35.95l14.8 6.34c50.3 21.57 78.7 43.56 78.7 93 0 53.3-41.87 82.5-98.1 82.5-54.98 0-90.5-26.2-107.88-60.54zm-209.13 5.13c9.3 16.5 17.76 30.45 38.1 30.45 19.45 0 31.72-7.61 31.72-37.2v-201.3h59.2v202.1c0 61.3-35.94 89.2-88.4 89.2-47.4 0-74.85-24.53-88.81-54.075z"/>
            </svg>
        </div>
        <ul>
            <li><a href="#selection">S√©lection</a></li>
            <li><a href="#creation">Cr√©ation</a></li>
            <li><a href="#modification">Modification</a></li>
            <li><a href="#evenements">√âv√©nements</a></li>
            <li><a href="#classes">Classes & Styles</a></li>
            <li><a href="#navigation">Navigation DOM</a></li>
            <li><a href="#attributs">Attributs</a></li>
        </ul>
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Rechercher..." />
        </div>
    </nav>

    <main>
        <section id="selection">
            <h2>üîç S√©lection d'√âl√©ments</h2>

            <div class="tag-card">
                <h3>document.getElementById()</h3>
                <p><strong>C'est quoi ?</strong> S√©lectionne un √©l√©ment HTML par son ID unique. C'est la m√©thode la plus rapide pour cibler un √©l√©ment sp√©cifique.</p>
                <p><strong>Pourquoi ?</strong> Utilise-la quand tu veux manipuler un seul √©l√©ment unique (ex: un bouton pr√©cis, un formulaire). Plus rapide que querySelector pour les IDs.</p>
                <p><strong>Exemple concret :</strong> R√©cup√©rer un bouton de connexion pour ajouter un √©v√©nement click ou changer son texte quand l'utilisateur se connecte.</p>
                <code>const btnLogin = document.getElementById('btn-login');
btnLogin.textContent = 'Connect√© !';
btnLogin.style.backgroundColor = 'green';</code>
            </div>

            <div class="tag-card">
                <h3>document.querySelector()</h3>
                <p><strong>C'est quoi ?</strong> S√©lectionne le PREMIER √©l√©ment qui correspond au s√©lecteur CSS. Tu peux utiliser tous les s√©lecteurs CSS (classes, attributs, pseudo-classes).</p>
                <p><strong>Pourquoi ?</strong> C'est la m√©thode la plus polyvalente. Utilise-la quand tu veux cibler un √©l√©ment avec un s√©lecteur pr√©cis, comme le premier bouton d'une classe.</p>
                <p><strong>Astuce :</strong> Si plusieurs √©l√©ments correspondent, seul le premier est retourn√©. Pour tous les avoir, utilise querySelectorAll.</p>
                <code>const premierBouton = document.querySelector('.btn-primary');
const emailInput = document.querySelector('input[type="email"]');
const lienActif = document.querySelector('a.active:hover');</code>
            </div>

            <div class="tag-card">
                <h3>document.querySelectorAll()</h3>
                <p><strong>C'est quoi ?</strong> S√©lectionne TOUS les √©l√©ments qui correspondent au s√©lecteur CSS. Retourne une NodeList que tu peux parcourir avec forEach.</p>
                <p><strong>Pourquoi ?</strong> Id√©al pour appliquer la m√™me action √† plusieurs √©l√©ments : masquer toutes les cartes, changer la couleur de tous les boutons, etc.</p>
                <p><strong>Exemple concret :</strong> Ajouter un √©v√©nement click √† tous les boutons "J'aime" d'une page de produits.</p>
                <code>const boutonsLike = document.querySelectorAll('.btn-like');
boutonsLike.forEach(btn => {
    btn.addEventListener('click', () => alert('Merci !'));
});</code>
            </div>

            <div class="tag-card">
                <h3>document.getElementsByClassName()</h3>
                <p><strong>C'est quoi ?</strong> S√©lectionne tous les √©l√©ments ayant une classe sp√©cifique. Retourne une HTMLCollection "live" qui se met √† jour automatiquement.</p>
                <p><strong>Pourquoi ?</strong> Moins utilis√©e que querySelectorAll car elle est "live" (se met √† jour automatiquement, ce qui peut causer des bugs). Pr√©f√®re querySelectorAll en g√©n√©ral.</p>
                <p><strong>Attention :</strong> Tu ne peux pas utiliser forEach directement dessus, il faut la convertir en tableau avec Array.from().</p>
                <code>const erreurs = document.getElementsByClassName('error');
Array.from(erreurs).forEach(err => {
    err.style.color = 'red';
});</code>
            </div>

            <div class="tag-card">
                <h3>document.getElementsByTagName()</h3>
                <p><strong>C'est quoi ?</strong> S√©lectionne tous les √©l√©ments d'un type de balise HTML sp√©cifique (div, p, img, button, etc.).</p>
                <p><strong>Pourquoi ?</strong> Utile pour manipuler tous les √©l√©ments du m√™me type en une fois, comme lazy-loader toutes les images d'une page.</p>
                <p><strong>Exemple pratique :</strong> Ajouter un attribut loading="lazy" √† toutes les images pour am√©liorer les performances.</p>
                <code>const images = document.getElementsByTagName('img');
Array.from(images).forEach(img => {
    img.loading = 'lazy';
    img.alt = img.alt || 'Image';
});</code>
            </div>

            <div class="tag-card">
                <h3>element.closest()</h3>
                <p><strong>C'est quoi ?</strong> Remonte dans l'arbre DOM pour trouver l'anc√™tre le plus proche qui correspond au s√©lecteur. Commence par l'√©l√©ment lui-m√™me.</p>
                <p><strong>Pourquoi ?</strong> Indispensable pour la d√©l√©gation d'√©v√©nements. Tu cliques sur un bouton et tu veux trouver sa carte parent pour la supprimer.</p>
                <p><strong>Astuce :</strong> Tr√®s utile avec les listes de t√¢ches ou cartes : clique sur "Supprimer" et trouve la carte parent pour la retirer.</p>
                <code>document.addEventListener('click', (e) => {
    if (e.target.classList.contains('btn-delete')) {
        const card = e.target.closest('.card');
        card.remove();
    }
});</code>
            </div>

            <div class="tag-card">
                <h3>element.matches()</h3>
                <p><strong>C'est quoi ?</strong> Teste si un √©l√©ment correspond √† un s√©lecteur CSS donn√©. Retourne true si oui, false sinon.</p>
                <p><strong>Pourquoi ?</strong> Pratique pour filtrer les clics : tu veux r√©agir seulement si on clique sur un bouton avec une classe sp√©cifique.</p>
                <p><strong>Usage courant :</strong> V√©rifie si l'√©l√©ment cliqu√© est bien celui que tu veux traiter avant d'ex√©cuter ton code.</p>
                <code>document.addEventListener('click', (e) => {
    if (e.target.matches('.btn-danger')) {
        if (confirm('Supprimer ?')) deleteItem();
    }
});</code>
            </div>
        </section>

        <section id="creation">
            <h2>üõ†Ô∏è Cr√©ation d'√âl√©ments</h2>

            <div class="tag-card">
                <h3>document.createElement()</h3>
                <p><strong>C'est quoi ?</strong> Cr√©e un nouvel √©l√©ment HTML en m√©moire. Il n'est pas encore visible, il faut l'ajouter au DOM avec appendChild ou append.</p>
                <p><strong>Pourquoi ?</strong> Pour construire du contenu dynamique : ajouter une nouvelle carte produit, cr√©er une notification, g√©n√©rer une liste de r√©sultats.</p>
                <p><strong>Exemple concret :</strong> Cr√©er une nouvelle carte de t√¢che quand l'utilisateur clique sur "Ajouter" dans une todo-list.</p>
                <code>const card = document.createElement('div');
card.className = 'task-card';
card.innerHTML = '&lt;h3&gt;Ma t√¢che&lt;/h3&gt;&lt;button&gt;Supprimer&lt;/button&gt;';
document.body.appendChild(card);</code>
            </div>

            <div class="tag-card">
                <h3>document.createTextNode()</h3>
                <p><strong>C'est quoi ?</strong> Cr√©e un n≈ìud de texte pur, sans aucune balise HTML. Le texte est automatiquement √©chapp√© (s√©curis√©).</p>
                <p><strong>Pourquoi ?</strong> Pour √©viter les failles XSS quand tu affiches du contenu venu d'utilisateurs. Le texte sera affich√© tel quel, sans √™tre interpr√©t√© comme du HTML.</p>
                <p><strong>S√©curit√© :</strong> Si un utilisateur entre "&lt;script&gt;alert('hack')&lt;/script&gt;", ce sera affich√© comme du texte et non ex√©cut√©.</p>
                <code>const userInput = '&lt;script&gt;alert("XSS")&lt;/script&gt;';
const safeText = document.createTextNode(userInput);
element.appendChild(safeText); // Affiche le texte, pas de code ex√©cut√©</code>
            </div>

            <div class="tag-card">
                <h3>element.cloneNode()</h3>
                <p><strong>C'est quoi ?</strong> Duplique un √©l√©ment existant. Avec cloneNode(true) tu copies aussi tous les enfants, avec false seulement l'√©l√©ment lui-m√™me.</p>
                <p><strong>Pourquoi ?</strong> Gain de temps : tu as une carte complexe que tu veux r√©utiliser ? Clone-la au lieu de la recr√©er enti√®rement.</p>
                <p><strong>Astuce :</strong> Les √©v√©nements ne sont PAS copi√©s. Tu devras les rajouter sur le clone.</p>
                <code>const templateCard = document.querySelector('.product-card');
const newCard = templateCard.cloneNode(true);
newCard.querySelector('h3').textContent = 'Nouveau produit';
document.body.appendChild(newCard);</code>
            </div>

            <div class="tag-card">
                <h3>element.appendChild()</h3>
                <p><strong>C'est quoi ?</strong> Ins√®re un √©l√©ment √† la fin d'un parent. L'√©l√©ment devient le dernier enfant du parent.</p>
                <p><strong>Pourquoi ?</strong> C'est la m√©thode classique pour ajouter un √©l√©ment au DOM et le rendre visible. Tous les √©l√©ments cr√©√©s doivent √™tre ajout√©s quelque part.</p>
                <p><strong>Attention :</strong> Si l'√©l√©ment existe d√©j√† ailleurs dans le DOM, il sera D√âPLAC√â, pas copi√©.</p>
                <code>const liste = document.getElementById('task-list');
const newTask = document.createElement('li');
newTask.textContent = 'Faire les courses';
liste.appendChild(newTask);</code>
            </div>

            <div class="tag-card">
                <h3>element.insertBefore()</h3>
                <p><strong>C'est quoi ?</strong> Ins√®re un nouvel √©l√©ment juste AVANT un √©l√©ment de r√©f√©rence dans un parent donn√©.</p>
                <p><strong>Pourquoi ?</strong> Pour placer pr√©cis√©ment un √©l√©ment, par exemple ins√©rer une t√¢che en premi√®re position d'une liste ou ajouter une ligne avant une autre.</p>
                <p><strong>Exemple pratique :</strong> Ajouter les nouvelles t√¢ches en haut de la liste plut√¥t qu'√† la fin.</p>
                <code>const liste = document.getElementById('tasks');
const newTask = document.createElement('li');
newTask.textContent = 'Nouvelle t√¢che urgente';
liste.insertBefore(newTask, liste.firstElementChild);</code>
            </div>

            <div class="tag-card">
                <h3>element.insertAdjacentHTML()</h3>
                <p><strong>C'est quoi ?</strong> Ins√®re du code HTML √† une position pr√©cise : beforebegin (avant), afterbegin (d√©but int√©rieur), beforeend (fin int√©rieur), afterend (apr√®s).</p>
                <p><strong>Pourquoi ?</strong> Tr√®s rapide pour ajouter du HTML complexe sans cr√©er manuellement chaque √©l√©ment. Parfait pour des templates.</p>
                <p><strong>Conseil :</strong> Utilise 'beforeend' pour ajouter √† la fin (comme appendChild) et 'afterbegin' pour ajouter au d√©but.</p>
                <code>const container = document.getElementById('notifications');
container.insertAdjacentHTML('afterbegin',
    '&lt;div class="alert"&gt;Nouveau message !&lt;/div&gt;');</code>
            </div>

            <div class="tag-card">
                <h3>element.insertAdjacentElement()</h3>
                <p><strong>C'est quoi ?</strong> Comme insertAdjacentHTML mais pour ins√©rer un √©l√©ment DOM existant (pas du HTML en string).</p>
                <p><strong>Pourquoi ?</strong> Quand tu as d√©j√† cr√©√© un √©l√©ment avec createElement et que tu veux le placer pr√©cis√©ment par rapport √† un autre.</p>
                <p><strong>Diff√©rence cl√© :</strong> Prend un √©l√©ment DOM, pas une string HTML. Plus s√ªr car pas de risque d'injection.</p>
                <code>const newBtn = document.createElement('button');
newBtn.textContent = 'Cliquez-moi';
element.insertAdjacentElement('afterend', newBtn);</code>
            </div>

            <div class="tag-card">
                <h3>element.append()</h3>
                <p><strong>C'est quoi ?</strong> Version moderne de appendChild. Tu peux ajouter plusieurs √©l√©ments ET du texte directement en une seule ligne.</p>
                <p><strong>Pourquoi ?</strong> Plus flexible et pratique. Tu peux passer du texte sans createTextNode, et ajouter plusieurs √©l√©ments d'un coup.</p>
                <p><strong>Bonus :</strong> Contrairement √† appendChild, ne retourne rien (undefined). Utilise appendChild si tu as besoin de cha√Æner.</p>
                <code>const container = document.getElementById('content');
container.append(
    document.createElement('h2'),
    'Voici du texte',
    document.createElement('p')
);</code>
            </div>

            <div class="tag-card">
                <h3>element.prepend()</h3>
                <p><strong>C'est quoi ?</strong> Comme append, mais ins√®re au D√âBUT au lieu de la fin. Peut aussi prendre plusieurs √©l√©ments et du texte.</p>
                <p><strong>Pourquoi ?</strong> Parfait pour ajouter les nouveaux messages en haut d'un chat, ou les nouvelles notifications en premier.</p>
                <p><strong>Use case :</strong> Les flux d'actualit√©s o√π tu veux que le contenu le plus r√©cent apparaisse en premier.</p>
                <code>const chatBox = document.getElementById('messages');
const newMsg = document.createElement('div');
newMsg.textContent = 'Nouveau message !';
chatBox.prepend(newMsg); // Appara√Æt en premier</code>
            </div>

            <div class="tag-card">
                <h3>element.before()</h3>
                <p><strong>C'est quoi ?</strong> Ins√®re un ou plusieurs √©l√©ments juste AVANT l'√©l√©ment actuel, comme des fr√®res/s≈ìurs au m√™me niveau.</p>
                <p><strong>Pourquoi ?</strong> Pour ajouter du contenu avant un √©l√©ment sans toucher √† son parent. Utile pour ins√©rer des s√©parateurs ou du contenu adjacent.</p>
                <p><strong>Exemple pratique :</strong> Ajouter un titre ou un avertissement juste avant un formulaire.</p>
                <code>const form = document.querySelector('form');
const warning = document.createElement('p');
warning.textContent = '‚ö†Ô∏è Remplissez tous les champs';
form.before(warning);</code>
            </div>

            <div class="tag-card">
                <h3>element.after()</h3>
                <p><strong>C'est quoi ?</strong> Ins√®re un ou plusieurs √©l√©ments juste APR√àS l'√©l√©ment actuel, au m√™me niveau dans le DOM.</p>
                <p><strong>Pourquoi ?</strong> Pratique pour ajouter des messages d'erreur apr√®s un champ de formulaire, ou des infos suppl√©mentaires apr√®s un √©l√©ment.</p>
                <p><strong>Cas d'usage :</strong> Afficher un message d'erreur rouge juste apr√®s un input invalide.</p>
                <code>const emailInput = document.getElementById('email');
const error = document.createElement('span');
error.textContent = 'Email invalide';
error.style.color = 'red';
emailInput.after(error);</code>
            </div>
        </section>

        <section id="modification">
            <h2>‚úèÔ∏è Modification d'√âl√©ments</h2>

            <div class="tag-card">
                <h3>element.innerHTML</h3>
                <p><strong>C'est quoi ?</strong> Lit ou remplace tout le contenu HTML √† l'int√©rieur d'un √©l√©ment. Attention, peut ex√©cuter du code malveillant !</p>
                <p><strong>Pourquoi ?</strong> Pratique pour changer rapidement tout le contenu d'un conteneur. Id√©al quand tu veux ins√©rer du HTML complet d'un coup.</p>
                <p><strong>Attention :</strong> N'utilise JAMAIS innerHTML avec du contenu venu d'utilisateurs sans le nettoyer (risque XSS). Privil√©gie textContent pour du texte.</p>
                <code>const container = document.getElementById('products');
container.innerHTML = '&lt;div class="card"&gt;&lt;h3&gt;Produit&lt;/h3&gt;&lt;p&gt;Prix: 10‚Ç¨&lt;/p&gt;&lt;/div&gt;';
// Remplace tout le contenu</code>
            </div>

            <div class="tag-card">
                <h3>element.textContent</h3>
                <p><strong>C'est quoi ?</strong> Lit ou modifie UNIQUEMENT le texte d'un √©l√©ment. Le HTML est √©chapp√© et affich√© comme du texte brut.</p>
                <p><strong>Pourquoi ?</strong> C'est la m√©thode S√âCURIS√âE pour afficher du contenu utilisateur. Aucun risque d'ex√©cution de code, le HTML est neutralis√©.</p>
                <p><strong>Best practice :</strong> Toujours utiliser textContent pour afficher des donn√©es utilisateur (commentaires, noms, messages).</p>
                <code>const username = '&lt;script&gt;alert("hack")&lt;/script&gt;';
title.textContent = username;
// Affiche exactement: &lt;script&gt;alert("hack")&lt;/script&gt;</code>
            </div>

            <div class="tag-card">
                <h3>element.innerText</h3>
                <p><strong>C'est quoi ?</strong> Comme textContent mais respecte les styles CSS : ignore les √©l√©ments display:none, respecte les retours √† la ligne CSS.</p>
                <p><strong>Pourquoi ?</strong> Utilise-le quand tu veux le texte "visible" tel que l'utilisateur le voit. Plus lent que textContent car calcule les styles.</p>
                <p><strong>Diff√©rence cl√© :</strong> innerText ignore le contenu cach√©, textContent prend tout. Pour la performance, pr√©f√®re textContent.</p>
                <code>// Si un span est display:none
element.innerText; // ignore le span cach√©
element.textContent; // inclut le span cach√©</code>
            </div>

            <div class="tag-card">
                <h3>element.remove()</h3>
                <p><strong>C'est quoi ?</strong> Supprime l'√©l√©ment du DOM instantan√©ment. L'√©l√©ment dispara√Æt compl√®tement de la page.</p>
                <p><strong>Pourquoi ?</strong> Pour nettoyer le DOM : supprimer une notification apr√®s 3 secondes, retirer une carte quand on clique sur "Supprimer".</p>
                <p><strong>Exemple concret :</strong> Fermer une popup ou supprimer une t√¢che d'une todo-list au clic.</p>
                <code>document.querySelectorAll('.btn-delete').forEach(btn => {
    btn.addEventListener('click', () => {
        btn.closest('.task').remove();
    });
});</code>
            </div>

            <div class="tag-card">
                <h3>element.removeChild()</h3>
                <p><strong>C'est quoi ?</strong> Le parent supprime un de ses enfants sp√©cifiques. M√©thode plus ancienne, pr√©f√®re element.remove() maintenant.</p>
                <p><strong>Pourquoi ?</strong> Utilis√©e dans l'ancien code. Aujourd'hui, element.remove() est plus simple et direct.</p>
                <p><strong>Astuce :</strong> Cette m√©thode retourne l'√©l√©ment supprim√©, utile si tu veux le r√©utiliser ailleurs ou le sauvegarder.</p>
                <code>const parent = document.getElementById('liste');
const premier = parent.firstElementChild;
const removed = parent.removeChild(premier); // supprime et retourne</code>
            </div>

            <div class="tag-card">
                <h3>element.replaceChild()</h3>
                <p><strong>C'est quoi ?</strong> Le parent remplace un de ses enfants par un nouvel √©l√©ment. M√©thode ancienne, pr√©f√®re replaceWith().</p>
                <p><strong>Pourquoi ?</strong> Pour √©changer un √©l√©ment contre un autre, comme remplacer un loader par le contenu r√©el une fois charg√©.</p>
                <p><strong>Note :</strong> replaceWith() est plus moderne et plus simple √† utiliser.</p>
                <code>const parent = document.getElementById('container');
const loader = document.getElementById('loader');
const content = document.createElement('div');
parent.replaceChild(content, loader);</code>
            </div>

            <div class="tag-card">
                <h3>element.replaceWith()</h3>
                <p><strong>C'est quoi ?</strong> Remplace l'√©l√©ment par un ou plusieurs nouveaux √©l√©ments. Plus moderne et simple que replaceChild.</p>
                <p><strong>Pourquoi ?</strong> Super pratique : remplacer un loader par du contenu, un bouton "Modifier" par un formulaire d'√©dition.</p>
                <p><strong>Exemple concret :</strong> Transformer un texte en input √©ditable quand on clique sur "Modifier".</p>
                <code>const loader = document.getElementById('loader');
const content = document.createElement('div');
content.innerHTML = '&lt;h2&gt;Contenu charg√© !&lt;/h2&gt;';
loader.replaceWith(content);</code>
            </div>

            <div class="tag-card">
                <h3>element.outerHTML</h3>
                <p><strong>C'est quoi ?</strong> Lit ou remplace l'√©l√©ment COMPLET, y compris sa balise ouvrante/fermante. innerHTML ne touche que l'int√©rieur.</p>
                <p><strong>Pourquoi ?</strong> Quand tu veux remplacer l'√©l√©ment ET sa balise, pas juste son contenu. Utile pour changer le type d'√©l√©ment.</p>
                <p><strong>Attention :</strong> Apr√®s remplacement, l'ancienne r√©f√©rence JavaScript ne fonctionne plus, r√©cup√®re le nouvel √©l√©ment.</p>
                <code>const oldDiv = document.getElementById('myDiv');
oldDiv.outerHTML = '&lt;section class="new"&gt;Nouveau&lt;/section&gt;';
// oldDiv n'existe plus, r√©cup√®re le nouveau</code>
            </div>
        </section>

        <section id="evenements">
            <h2>‚ö° Gestion des √âv√©nements</h2>

            <div class="tag-card">
                <h3>element.addEventListener()</h3>
                <p><strong>C'est quoi ?</strong> √âcoute un √©v√©nement (click, mouseover, keydown...) et ex√©cute une fonction quand il se produit. C'est le c≈ìur de l'interactivit√© web.</p>
                <p><strong>Pourquoi ?</strong> Pour rendre ton site vivant : r√©agir aux clics, aux survols, √† la frappe clavier. Tu peux avoir plusieurs √©couteurs sur le m√™me √©l√©ment.</p>
                <p><strong>√âv√©nements courants :</strong> 'click', 'submit', 'input', 'change', 'mouseover', 'keydown', 'scroll'. Utilise { once: true } pour un √©v√©nement unique.</p>
                <code>const btn = document.getElementById('subscribe');
btn.addEventListener('click', () => {
    alert('Merci de votre inscription !');
}, { once: true }); // Se d√©clenche une seule fois</code>
            </div>

            <div class="tag-card">
                <h3>element.removeEventListener()</h3>
                <p><strong>C'est quoi ?</strong> Retire un √©couteur d'√©v√©nement pr√©c√©demment ajout√©. IMPORTANT : la fonction doit √™tre la m√™me r√©f√©rence.</p>
                <p><strong>Pourquoi ?</strong> √âviter les fuites m√©moire et les bugs. Quand tu d√©truis un composant, nettoie ses √©v√©nements.</p>
                <p><strong>Astuce critique :</strong> Tu DOIS utiliser une fonction nomm√©e (pas anonyme) pour pouvoir la retirer plus tard.</p>
                <code>function handleClick() { console.log('Cliqu√© !'); }
btn.addEventListener('click', handleClick);
// Plus tard...
btn.removeEventListener('click', handleClick); // Fonctionne ‚úì</code>
            </div>

            <div class="tag-card">
                <h3>event.preventDefault()</h3>
                <p><strong>C'est quoi ?</strong> Annule le comportement par d√©faut d'un √©v√©nement : emp√™che un lien de naviguer, un formulaire de se soumettre, etc.</p>
                <p><strong>Pourquoi ?</strong> Pour g√©rer toi-m√™me l'action avec JavaScript au lieu du comportement natif du navigateur.</p>
                <p><strong>Use cases :</strong> Valider un formulaire avant envoi, faire un menu custom au clic droit, emp√™cher un lien de recharger la page.</p>
                <code>form.addEventListener('submit', (e) => {
    e.preventDefault();
    const data = new FormData(form);
    // Envoie en AJAX au lieu du rechargement de page
});</code>
            </div>

            <div class="tag-card">
                <h3>event.stopPropagation()</h3>
                <p><strong>C'est quoi ?</strong> Stoppe la propagation de l'√©v√©nement vers les parents (bubbling). L'√©v√©nement ne remonte plus dans l'arbre DOM.</p>
                <p><strong>Pourquoi ?</strong> √âviter qu'un clic sur un bouton enfant d√©clenche aussi l'√©v√©nement du parent. Utile pour les menus, modales, cartes cliquables.</p>
                <p><strong>Exemple concret :</strong> Tu as une carte cliquable avec un bouton "Supprimer". Sans stopPropagation, cliquer "Supprimer" ouvre aussi la carte.</p>
                <code>card.addEventListener('click', () => console.log('Carte ouverte'));
deleteBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // N'ouvre pas la carte
    card.remove();
});</code>
            </div>

            <div class="tag-card">
                <h3>event.target</h3>
                <p><strong>C'est quoi ?</strong> L'√©l√©ment pr√©cis qui a d√©clench√© l'√©v√©nement (celui vraiment cliqu√©, pas son parent).</p>
                <p><strong>Pourquoi ?</strong> Essentiel pour la d√©l√©gation d'√©v√©nements : un seul listener sur le parent pour g√©rer tous les enfants.</p>
                <p><strong>Pattern puissant :</strong> Mettre un listener sur une liste et d√©tecter quel item a √©t√© cliqu√© avec e.target.</p>
                <code>document.getElementById('task-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-btn')) {
        e.target.closest('li').remove();
    }
});</code>
            </div>

            <div class="tag-card">
                <h3>event.currentTarget</h3>
                <p><strong>C'est quoi ?</strong> L'√©l√©ment sur lequel le listener est attach√© (pas forc√©ment celui cliqu√©). Diff√©rent de target si on clique sur un enfant.</p>
                <p><strong>Pourquoi ?</strong> Pour acc√©der √† l'√©l√©ment √©cout√© m√™me si on clique sur un de ses enfants. Utile pour les d√©l√©gations.</p>
                <p><strong>Diff√©rence cl√© :</strong> target = √©l√©ment cliqu√©, currentTarget = √©l√©ment avec le listener. En pratique, on utilise plus souvent target.</p>
                <code>card.addEventListener('click', (e) => {
    console.log(e.target); // Le span cliqu√©
    console.log(e.currentTarget); // La card (toujours)
    e.currentTarget.classList.toggle('selected');
});</code>
            </div>

            <div class="tag-card">
                <h3>element.dispatchEvent()</h3>
                <p><strong>C'est quoi ?</strong> D√©clenche manuellement un √©v√©nement sur un √©l√©ment, comme si l'utilisateur avait fait l'action.</p>
                <p><strong>Pourquoi ?</strong> Pour simuler des interactions : d√©clencher un clic automatique, simuler une soumission de formulaire, cr√©er des √©v√©nements custom.</p>
                <p><strong>Cas pratique :</strong> D√©clencher automatiquement le clic sur un bouton cach√© de file input quand on clique sur un bouton stylis√©.</p>
                <code>// Simuler un clic sur le file input
customBtn.addEventListener('click', () => {
    fileInput.click();
});
// Ou avec dispatchEvent
fileInput.dispatchEvent(new MouseEvent('click'));</code>
            </div>
        </section>

        <section id="classes">
            <h2>üé® Classes et Styles</h2>

            <div class="tag-card">
                <h3>element.classList.add()</h3>
                <p><strong>C'est quoi ?</strong> Ajoute une ou plusieurs classes CSS √† un √©l√©ment. C'est la m√©thode moderne pour appliquer des styles dynamiques.</p>
                <p><strong>Pourquoi ?</strong> Pour changer l'apparence d'un √©l√©ment : rendre un bouton actif, montrer une erreur, appliquer un th√®me. Plus propre que manipuler className.</p>
                <p><strong>Best practice :</strong> D√©finis tes styles en CSS, et ajoute/retire les classes avec JS. S√©pare la logique de la pr√©sentation.</p>
                <code>const btn = document.querySelector('.btn');
btn.classList.add('active', 'primary');
// Ajoute plusieurs classes d'un coup</code>
            </div>

            <div class="tag-card">
                <h3>element.classList.remove()</h3>
                <p><strong>C'est quoi ?</strong> Retire une ou plusieurs classes CSS d'un √©l√©ment.</p>
                <p><strong>Pourquoi ?</strong> Pour d√©sactiver un √©tat, retirer une erreur, changer l'apparence. Enlever une classe est plus propre que surcharger avec des styles inline.</p>
                <p><strong>Astuce :</strong> Aucune erreur si la classe n'existe pas. Tu peux retirer en toute s√©curit√©.</p>
                <code>// Retirer un √©tat d'erreur apr√®s validation
input.classList.remove('error', 'invalid');
input.classList.add('valid');</code>
            </div>

            <div class="tag-card">
                <h3>element.classList.toggle()</h3>
                <p><strong>C'est quoi ?</strong> Inverse une classe : l'ajoute si absente, la retire si pr√©sente. Parfait pour les √©tats on/off.</p>
                <p><strong>Pourquoi ?</strong> Super pratique pour les menus hamburger, les accord√©ons, les modes dark/light, tout ce qui s'active/d√©sactive.</p>
                <p><strong>Bonus :</strong> Retourne true si la classe est ajout√©e, false si retir√©e. Tu peux forcer avec un 2e param√®tre : toggle('active', true) force l'ajout.</p>
                <code>// Menu hamburger
menuBtn.addEventListener('click', () => {
    nav.classList.toggle('open');
    menuBtn.classList.toggle('active');
});</code>
            </div>

            <div class="tag-card">
                <h3>element.classList.contains()</h3>
                <p><strong>C'est quoi ?</strong> V√©rifie si un √©l√©ment poss√®de une classe donn√©e. Retourne true ou false.</p>
                <p><strong>Pourquoi ?</strong> Pour conditionner ton code : ex√©cuter une action seulement si l'√©l√©ment a un certain √©tat.</p>
                <p><strong>Use case :</strong> V√©rifier qu'un menu est ouvert avant de le fermer, ou qu'un √©l√©ment est s√©lectionn√© avant de le traiter.</p>
                <code>if (modal.classList.contains('open')) {
    modal.classList.remove('open');
} else {
    modal.classList.add('open');
}</code>
            </div>

            <div class="tag-card">
                <h3>element.classList.replace()</h3>
                <p><strong>C'est quoi ?</strong> Remplace une classe par une autre en une seule op√©ration.</p>
                <p><strong>Pourquoi ?</strong> Plus efficace et lisible que remove() puis add(). Id√©al pour changer d'√©tat ou de th√®me.</p>
                <p><strong>Exemple concret :</strong> Passer d'un bouton "primary" √† "danger", ou changer le th√®me de "light" √† "dark".</p>
                <code>// Changer l'√©tat d'un bouton
saveBtn.classList.replace('btn-primary', 'btn-success');
// Changer de th√®me
body.classList.replace('theme-light', 'theme-dark');</code>
            </div>

            <div class="tag-card">
                <h3>element.className</h3>
                <p><strong>C'est quoi ?</strong> Lit ou d√©finit TOUTES les classes comme une string. Ancien syst√®me, moins pratique que classList.</p>
                <p><strong>Pourquoi ?</strong> Utile pour remplacer toutes les classes d'un coup ou lire toutes les classes en une cha√Æne.</p>
                <p><strong>Attention :</strong> √âcrase toutes les classes existantes. Pr√©f√®re classList pour ajouter/retirer des classes sp√©cifiques.</p>
                <code>// Remplacer toutes les classes
element.className = 'box rounded shadow-lg';
// Lire les classes
console.log(element.className); // "box rounded shadow-lg"</code>
            </div>

            <div class="tag-card">
                <h3>element.style</h3>
                <p><strong>C'est quoi ?</strong> Modifie les styles CSS inline directement sur l'√©l√©ment. Prioritaire sur les CSS externes.</p>
                <p><strong>Pourquoi ?</strong> Pour des styles dynamiques calcul√©s : positions, couleurs variables, animations. Les styles inline ont la priorit√© maximale (sauf !important).</p>
                <p><strong>Conseil :</strong> Pr√©f√®re les classes CSS pour les styles fixes. Utilise .style pour les valeurs calcul√©es ou temporaires.</p>
                <code>// Positionner dynamiquement une tooltip
tooltip.style.left = mouseX + 'px';
tooltip.style.top = mouseY + 'px';
tooltip.style.opacity = '1';</code>
            </div>

            <div class="tag-card">
                <h3>element.style.cssText</h3>
                <p><strong>C'est quoi ?</strong> D√©finit plusieurs styles CSS en une seule string. Plus rapide que de les d√©finir un par un.</p>
                <p><strong>Pourquoi ?</strong> Performance : applique plusieurs styles en une seule op√©ration. Utile pour des styles temporaires ou calcul√©s.</p>
                <p><strong>Attention :</strong> √âcrase tous les styles inline existants. Pour ajouter sans √©craser, utilise += pour concat√©ner.</p>
                <code>// Appliquer plusieurs styles d'un coup
notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #4caf50;
`;</code>
            </div>

            <div class="tag-card">
                <h3>getComputedStyle()</h3>
                <p><strong>C'est quoi ?</strong> R√©cup√®re les styles CSS finaux calcul√©s par le navigateur (incluant CSS externe, inline, h√©ritage).</p>
                <p><strong>Pourquoi ?</strong> Pour LIRE les vraies valeurs appliqu√©es. element.style ne lit que les styles inline, pas ceux du CSS externe.</p>
                <p><strong>Use case :</strong> R√©cup√©rer la hauteur actuelle d'un √©l√©ment pour une animation, ou v√©rifier si un √©l√©ment est visible.</p>
                <code>const styles = getComputedStyle(element);
const currentColor = styles.color; // "rgb(255, 0, 0)"
const height = parseInt(styles.height); // 150</code>
            </div>
        </section>

        <section id="navigation">
            <h2>üß≠ Navigation dans le DOM</h2>

            <div class="tag-card">
                <h3>element.parentNode / element.parentElement</h3>
                <p><strong>C'est quoi ?</strong> R√©cup√®re le parent direct. parentElement retourne seulement les √©l√©ments HTML, parentNode peut retourner le document.</p>
                <p><strong>Pourquoi ?</strong> Pour remonter d'un niveau dans l'arbre : trouver le conteneur d'un bouton, le formulaire d'un input.</p>
                <p><strong>Conseil :</strong> Utilise parentElement en g√©n√©ral, c'est plus pr√©visible. parentNode peut retourner des nodes non-HTML.</p>
                <code>const deleteBtn = document.querySelector('.delete');
const taskItem = deleteBtn.parentElement; // Le &lt;li&gt; parent
taskItem.remove(); // Supprime toute la t√¢che</code>
            </div>

            <div class="tag-card">
                <h3>element.children</h3>
                <p><strong>C'est quoi ?</strong> Retourne une HTMLCollection des enfants directs (uniquement les √©l√©ments, pas le texte).</p>
                <p><strong>Pourquoi ?</strong> Pour parcourir les √©l√©ments enfants et les manipuler : compter les items d'une liste, styliser chaque carte.</p>
                <p><strong>Astuce :</strong> children est "live", se met √† jour automatiquement. Pour un tableau fixe, utilise Array.from(element.children).</p>
                <code>const liste = document.getElementById('tasks');
const nbTasks = liste.children.length;
Array.from(liste.children).forEach((task, i) => {
    task.textContent = `T√¢che ${i + 1}`;
});</code>
            </div>

            <div class="tag-card">
                <h3>element.childNodes</h3>
                <p><strong>C'est quoi ?</strong> Retourne TOUS les n≈ìuds enfants : √©l√©ments, texte, commentaires, m√™me les espaces vides.</p>
                <p><strong>Pourquoi ?</strong> Rarement utilis√© car inclut les espaces entre balises. Pr√©f√®re children pour avoir seulement les √©l√©ments.</p>
                <p><strong>Pi√®ge :</strong> Un &lt;div&gt;‚éµ&lt;p&gt;&lt;/p&gt;‚éµ&lt;/div&gt; a 3 childNodes (texte, p, texte) mais 1 seul children (p).</p>
                <code>// HTML: &lt;div&gt; &lt;p&gt;Texte&lt;/p&gt; &lt;/div&gt;
div.childNodes.length; // 3 (texte, p, texte)
div.children.length; // 1 (seulement p)</code>
            </div>

            <div class="tag-card">
                <h3>element.firstElementChild / element.lastElementChild</h3>
                <p><strong>C'est quoi ?</strong> Acc√®s direct au premier ou dernier enfant √©l√©ment (ignore le texte et les espaces).</p>
                <p><strong>Pourquoi ?</strong> Acc√®s rapide sans boucle : r√©cup√©rer le premier item d'une liste, le dernier message d'un chat.</p>
                <p><strong>Best practice :</strong> Toujours pr√©f√©rer firstElementChild √† firstChild pour √©viter les n≈ìuds texte.</p>
                <code>const liste = document.getElementById('messages');
const dernierMsg = liste.lastElementChild;
dernierMsg.scrollIntoView(); // Scroll vers le dernier message</code>
            </div>

            <div class="tag-card">
                <h3>element.firstChild / element.lastChild</h3>
                <p><strong>C'est quoi ?</strong> Premier ou dernier n≈ìud enfant, peut √™tre du texte vide ou un commentaire.</p>
                <p><strong>Pourquoi ?</strong> D√©conseill√© car impr√©visible. Un espace entre balises compte comme firstChild. Utilise firstElementChild.</p>
                <p><strong>Erreur fr√©quente :</strong> &lt;ul&gt;‚éµ&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt; : firstChild est un texte (l'espace), pas le &lt;li&gt; !</p>
                <code>// ‚ùå Risqu√©
ul.firstChild; // Peut √™tre un espace
// ‚úÖ S√ªr
ul.firstElementChild; // Toujours le premier &lt;li&gt;</code>
            </div>

            <div class="tag-card">
                <h3>element.nextElementSibling / element.previousElementSibling</h3>
                <p><strong>C'est quoi ?</strong> L'√©l√©ment fr√®re suivant ou pr√©c√©dent au m√™me niveau dans le DOM.</p>
                <p><strong>Pourquoi ?</strong> Pour naviguer entre √©l√©ments fr√®res : passer d'un onglet au suivant, comparer des √©l√©ments adjacents.</p>
                <p><strong>Use case :</strong> Cr√©er une navigation entre slides, ou s√©lectionner l'item suivant dans une liste.</p>
                <code>const currentSlide = document.querySelector('.slide.active');
currentSlide.classList.remove('active');
const nextSlide = currentSlide.nextElementSibling || slides[0];
nextSlide.classList.add('active');</code>
            </div>

            <div class="tag-card">
                <h3>element.nextSibling / element.previousSibling</h3>
                <p><strong>C'est quoi ?</strong> Le n≈ìud fr√®re suivant/pr√©c√©dent, peut √™tre du texte. M√™me probl√®me que firstChild.</p>
                <p><strong>Pourquoi ?</strong> √âvite-le. Les espaces entre balises comptent comme n≈ìuds. Utilise nextElementSibling.</p>
                <p><strong>R√®gle d'or :</strong> Tout ce qui finit par "Element" (nextElementSibling, firstElementChild) est fiable. Le reste peut retourner du texte.</p>
                <code>// ‚ùå Impr√©visible
li.nextSibling; // Peut √™tre un espace
// ‚úÖ Fiable
li.nextElementSibling; // Toujours un √©l√©ment</code>
            </div>

            <div class="tag-card">
                <h3>element.hasChildNodes()</h3>
                <p><strong>C'est quoi ?</strong> V√©rifie si un √©l√©ment a des enfants (√©l√©ments, texte, commentaires). Retourne true/false.</p>
                <p><strong>Pourquoi ?</strong> Pour v√©rifier si un conteneur est vide avant de faire une action : afficher un message "Aucun r√©sultat".</p>
                <p><strong>Alternative :</strong> Utilise element.children.length > 0 pour v√©rifier seulement les √©l√©ments (pas le texte).</p>
                <code>const resultats = document.getElementById('search-results');
if (resultats.children.length === 0) {
    resultats.innerHTML = '&lt;p&gt;Aucun r√©sultat&lt;/p&gt;';
}</code>
            </div>

            <div class="tag-card">
                <h3>document.documentElement</h3>
                <p><strong>C'est quoi ?</strong> R√©f√©rence directe √† la balise &lt;html&gt;, la racine du document.</p>
                <p><strong>Pourquoi ?</strong> Pour appliquer des classes/styles globaux : mode sombre, langue, zoom. Tr√®s utilis√© pour les th√®mes.</p>
                <p><strong>Pattern courant :</strong> Ajouter une classe sur &lt;html&gt; pour changer tout le th√®me avec CSS.</p>
                <code>// Toggle dark mode
const darkModeBtn = document.getElementById('theme-toggle');
darkModeBtn.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark-theme');
});</code>
            </div>

            <div class="tag-card">
                <h3>document.body</h3>
                <p><strong>C'est quoi ?</strong> R√©f√©rence directe au &lt;body&gt;. Acc√®s rapide sans querySelector.</p>
                <p><strong>Pourquoi ?</strong> Pour ajouter des √©l√©ments globaux (modales, overlays, notifications) ou changer le style de toute la page.</p>
                <p><strong>Exemple concret :</strong> Ajouter une overlay de chargement, bloquer le scroll, changer la couleur de fond.</p>
                <code>// Bloquer le scroll pendant une modale
document.body.style.overflow = 'hidden';
// Ajouter une notification globale
const notif = document.createElement('div');
document.body.appendChild(notif);</code>
            </div>

            <div class="tag-card">
                <h3>document.head</h3>
                <p><strong>C'est quoi ?</strong> R√©f√©rence directe au &lt;head&gt;. Pour manipuler les m√©tadonn√©es et ressources.</p>
                <p><strong>Pourquoi ?</strong> Charger dynamiquement des scripts, des styles, modifier le titre ou les meta tags.</p>
                <p><strong>Use cases :</strong> Lazy load de scripts externes, injection de styles, modification du SEO dynamique.</p>
                <code>// Charger un script dynamiquement
const script = document.createElement('script');
script.src = 'https://cdn.example.com/library.js';
document.head.appendChild(script);</code>
            </div>
        </section>

        <section id="attributs">
            <h2>üè∑Ô∏è Gestion des Attributs</h2>

            <div class="tag-card">
                <h3>element.getAttribute()</h3>
                <p><strong>C'est quoi ?</strong> R√©cup√®re la valeur d'un attribut HTML : href, src, data-*, alt, title, etc.</p>
                <p><strong>Pourquoi ?</strong> Pour lire des infos stock√©es dans les attributs : r√©cup√©rer une URL, un ID, des data attributes personnalis√©s.</p>
                <p><strong>Note :</strong> Pour les attributs courants (id, src, href), utilise l'acc√®s direct (element.id) c'est plus rapide.</p>
                <code>const productId = card.getAttribute('data-product-id');
const imageUrl = img.getAttribute('src');
const linkTarget = a.getAttribute('target'); // "_blank"</code>
            </div>

            <div class="tag-card">
                <h3>element.setAttribute()</h3>
                <p><strong>C'est quoi ?</strong> D√©finit ou modifie n'importe quel attribut HTML.</p>
                <p><strong>Pourquoi ?</strong> Changer dynamiquement les attributs : modifier une image, un lien, ajouter des data attributes, changer l'accessibilit√©.</p>
                <p><strong>Use cases :</strong> Changer l'image d'un carrousel, mettre √† jour un lien dynamique, modifier l'attribut alt pour l'accessibilit√©.</p>
                <code>// Changer l'image affich√©e
productImg.setAttribute('src', newImageUrl);
productImg.setAttribute('alt', productName);
// Rendre un lien externe
link.setAttribute('target', '_blank');</code>
            </div>

            <div class="tag-card">
                <h3>element.removeAttribute()</h3>
                <p><strong>C'est quoi ?</strong> Supprime compl√®tement un attribut d'un √©l√©ment HTML.</p>
                <p><strong>Pourquoi ?</strong> R√©activer un bouton (retirer disabled), rendre un √©l√©ment visible (retirer hidden), nettoyer des data attributes.</p>
                <p><strong>Exemple pratique :</strong> R√©activer le bouton "Envoyer" apr√®s validation du formulaire.</p>
                <code>// Activer le bouton apr√®s chargement
submitBtn.removeAttribute('disabled');
// Retirer un attribut temporaire
element.removeAttribute('data-loading');</code>
            </div>

            <div class="tag-card">
                <h3>element.hasAttribute()</h3>
                <p><strong>C'est quoi ?</strong> V√©rifie si un attribut existe sur un √©l√©ment. Retourne true si pr√©sent, false sinon.</p>
                <p><strong>Pourquoi ?</strong> Pour v√©rifier un √©tat avant d'agir : est-ce que le bouton est d√©sactiv√© ? L'√©l√©ment a-t-il un data attribute ?</p>
                <p><strong>Astuce :</strong> Utile pour √©viter les erreurs. V√©rifie que l'attribut existe avant de le lire.</p>
                <code>if (!submitBtn.hasAttribute('disabled')) {
    submitBtn.click(); // Clique seulement si actif
}
if (element.hasAttribute('data-user-id')) {
    loadUserData(element.getAttribute('data-user-id'));
}</code>
            </div>

            <div class="tag-card">
                <h3>element.toggleAttribute()</h3>
                <p><strong>C'est quoi ?</strong> Ajoute l'attribut s'il est absent, le retire s'il est pr√©sent. Comme classList.toggle mais pour les attributs.</p>
                <p><strong>Pourquoi ?</strong> Parfait pour les attributs bool√©ens : disabled, hidden, readonly. √âvite les if/else.</p>
                <p><strong>Bonus :</strong> Retourne true si ajout√©, false si retir√©. Tu peux forcer : toggleAttribute('hidden', false) garantit la suppression.</p>
                <code>// Toggle disabled sur un bouton
loadMoreBtn.toggleAttribute('disabled');
// Forcer un √©tat
input.toggleAttribute('readonly', true); // Force readonly</code>
            </div>

            <div class="tag-card">
                <h3>element.attributes</h3>
                <p><strong>C'est quoi ?</strong> Collection de TOUS les attributs de l'√©l√©ment (NamedNodeMap).</p>
                <p><strong>Pourquoi ?</strong> Rarement utilis√©. Utile pour debugger ou copier tous les attributs d'un √©l√©ment √† un autre.</p>
                <p><strong>Note :</strong> En pratique, tu connais g√©n√©ralement les attributs que tu veux. Utilise getAttribute directement.</p>
                <code>// Debugger : voir tous les attributs
for (let attr of element.attributes) {
    console.log(`${attr.name} = ${attr.value}`);
}</code>
            </div>

            <div class="tag-card">
                <h3>element.id</h3>
                <p><strong>C'est quoi ?</strong> Acc√®s direct en lecture/√©criture √† l'ID de l'√©l√©ment. Plus rapide que getAttribute('id').</p>
                <p><strong>Pourquoi ?</strong> Modifier l'ID dynamiquement, ou le lire pour construire un s√©lecteur ou une URL.</p>
                <p><strong>Use case :</strong> G√©n√©rer des IDs uniques pour des √©l√©ments cr√©√©s dynamiquement, ou construire des liens d'ancrage.</p>
                <code>// G√©n√©rer un ID unique
newElement.id = `item-${Date.now()}`;
// Cr√©er un lien d'ancrage
const anchorLink = `#${section.id}`;</code>
            </div>

            <div class="tag-card">
                <h3>element.dataset</h3>
                <p><strong>C'est quoi ?</strong> Objet pour acc√©der aux data-* attributes. data-user-id devient dataset.userId (camelCase automatique).</p>
                <p><strong>Pourquoi ?</strong> LA m√©thode pour stocker des donn√©es custom sur les √©l√©ments : IDs, states, config. Plus propre que des attributs normaux.</p>
                <p><strong>Pattern puissant :</strong> Stocke l'ID d'un produit sur sa carte, r√©cup√®re-le au clic pour l'ajouter au panier.</p>
                <code>// HTML: &lt;div class="product" data-id="42" data-price="19.99"&gt;
card.addEventListener('click', () => {
    addToCart(card.dataset.id, card.dataset.price);
});</code>
            </div>

            <div class="tag-card">
                <h3>element.value</h3>
                <p><strong>C'est quoi ?</strong> La valeur d'un champ de formulaire (input, textarea, select). C'est ce que l'utilisateur a entr√©.</p>
                <p><strong>Pourquoi ?</strong> ESSENTIEL pour tous les formulaires. R√©cup√©rer le texte tap√©, les options s√©lectionn√©es, vider un champ.</p>
                <p><strong>Best practice :</strong> Toujours trim() les inputs texte pour retirer les espaces inutiles.</p>
                <code>const email = emailInput.value.trim();
const password = passwordInput.value;
// Vider apr√®s envoi
form.addEventListener('submit', (e) => {
    e.preventDefault();
    sendData(emailInput.value);
    emailInput.value = ''; // Vide le champ
});</code>
            </div>

            <div class="tag-card">
                <h3>element.checked</h3>
                <p><strong>C'est quoi ?</strong> √âtat coch√©/d√©coch√© d'une checkbox ou radio button. Boolean : true = coch√©, false = d√©coch√©.</p>
                <p><strong>Pourquoi ?</strong> Savoir si une case est coch√©e (acceptation CGV, filtre actif) ou cocher/d√©cocher par code.</p>
                <p><strong>Exemple concret :</strong> Activer le bouton "S'inscrire" seulement si la checkbox CGV est coch√©e.</p>
                <code>const cgvCheckbox = document.getElementById('accept-terms');
const submitBtn = document.getElementById('submit');
cgvCheckbox.addEventListener('change', () => {
    submitBtn.disabled = !cgvCheckbox.checked;
});</code>
            </div>

            <div class="tag-card">
                <h3>element.disabled</h3>
                <p><strong>C'est quoi ?</strong> Active (false) ou d√©sactive (true) un champ de formulaire. Les champs disabled ne sont pas envoy√©s.</p>
                <p><strong>Pourquoi ?</strong> Emp√™cher l'interaction : bloquer un bouton pendant un chargement, d√©sactiver des champs selon des conditions.</p>
                <p><strong>Attention :</strong> Un champ disabled n'envoie PAS sa valeur dans le formulaire. Pour envoyer quand m√™me, utilise readonly.</p>
                <code>// Bouton de chargement
submitBtn.disabled = true;
submitBtn.textContent = 'Chargement...';
fetch('/api').then(() => submitBtn.disabled = false);</code>
            </div>

            <div class="tag-card">
                <h3>element.href / element.src</h3>
                <p><strong>C'est quoi ?</strong> Acc√®s direct aux URLs : href pour les liens (&lt;a&gt;), src pour images/scripts (&lt;img&gt;, &lt;script&gt;).</p>
                <p><strong>Pourquoi ?</strong> Modifier dynamiquement les liens et images. Plus simple et rapide que setAttribute.</p>
                <p><strong>Use cases :</strong> Changer l'image d'une galerie, mettre √† jour un lien selon l'√©tat, lazy load d'images.</p>
                <code>// Carrousel d'images
nextBtn.addEventListener('click', () => {
    currentIndex++;
    mainImage.src = images[currentIndex];
    mainImage.alt = `Image ${currentIndex + 1}`;
});</code>
            </div>
        </section>

        <section id="dimensions">
            <h2>üìè Dimensions et Position</h2>

            <div class="tag-card">
                <h3>element.offsetWidth / element.offsetHeight</h3>
                <p><strong>C'est quoi ?</strong> La taille TOTALE de l'√©l√©ment incluant contenu + padding + bordures. C'est l'espace r√©ellement occup√© sur la page.</p>
                <p><strong>Pourquoi ?</strong> Pour conna√Ætre les dimensions compl√®tes d'un √©l√©ment : dimensionner un conteneur, v√©rifier si un √©l√©ment rentre dans un espace.</p>
                <p><strong>Use case :</strong> V√©rifier si une image est trop grande, calculer l'espace n√©cessaire pour un √©l√©ment dynamique.</p>
                <code>const img = document.querySelector('img');
if (img.offsetWidth > 800) {
    img.style.maxWidth = '100%'; // Responsive
}
console.log(`Taille: ${img.offsetWidth}x${img.offsetHeight}px`);</code>
            </div>

            <div class="tag-card">
                <h3>element.clientWidth / element.clientHeight</h3>
                <p><strong>C'est quoi ?</strong> Largeur/hauteur de la zone de contenu (contenu + padding) SANS les bordures ni scrollbar.</p>
                <p><strong>Pourquoi ?</strong> Pour conna√Ætre l'espace disponible √† l'int√©rieur : dimensionner un canvas, calculer des positions relatives au contenu.</p>
                <p><strong>Diff√©rence cl√© :</strong> offsetWidth inclut les bordures, clientWidth non. Si bordure 2px, offsetWidth = clientWidth + 4px.</p>
                <code>// Dimensionner un canvas √† la taille du conteneur
const container = document.getElementById('canvas-wrapper');
canvas.width = container.clientWidth;
canvas.height = container.clientHeight;</code>
            </div>

            <div class="tag-card">
                <h3>element.scrollWidth / element.scrollHeight</h3>
                <p><strong>C'est quoi ?</strong> Taille TOTALE du contenu, incluant la partie cach√©e par le scroll. Plus grand que clientWidth si √ßa d√©borde.</p>
                <p><strong>Pourquoi ?</strong> D√©tecter si un √©l√©ment a du contenu scrollable, v√©rifier si l'utilisateur a scroll√© jusqu'en bas.</p>
                <p><strong>Pattern utile :</strong> D√©tecter si l'utilisateur a lu tout le texte d'un CGU avant d'activer "J'accepte".</p>
                <code>const terms = document.getElementById('terms');
terms.addEventListener('scroll', () => {
    const isBottom = terms.scrollTop + terms.clientHeight >= terms.scrollHeight - 10;
    if (isBottom) acceptBtn.disabled = false; // D√©bloquer
});</code>
            </div>

            <div class="tag-card">
                <h3>element.offsetLeft / element.offsetTop</h3>
                <p><strong>C'est quoi ?</strong> Distance en pixels de l'√©l√©ment par rapport √† son offsetParent (parent positionn√© le plus proche).</p>
                <p><strong>Pourquoi ?</strong> Pour calculer la position relative d'un √©l√©ment dans son conteneur. Utile pour les tooltips, drag & drop.</p>
                <p><strong>Attention :</strong> Relatif au parent positionn√© (position: relative/absolute/fixed), pas forc√©ment le parent direct.</p>
                <code>// Positionner une tooltip au-dessus d'un √©l√©ment
const tooltip = document.getElementById('tooltip');
tooltip.style.left = element.offsetLeft + 'px';
tooltip.style.top = (element.offsetTop - 50) + 'px';</code>
            </div>

            <div class="tag-card">
                <h3>element.scrollLeft / element.scrollTop</h3>
                <p><strong>C'est quoi ?</strong> Position actuelle du scroll horizontal/vertical. En lecture ET √©criture : tu peux lire ou modifier le scroll.</p>
                <p><strong>Pourquoi ?</strong> Contr√¥ler le scroll par code : scroll vers le haut, retenir la position de scroll, cr√©er un carousel horizontal.</p>
                <p><strong>Exemple pratique :</strong> Bouton "Retour en haut" qui scroll la page vers le top.</p>
                <code>// Bouton retour en haut
backToTopBtn.addEventListener('click', () => {
    document.documentElement.scrollTop = 0;
    // Ou avec animation:
    window.scrollTo({ top: 0, behavior: 'smooth' });
});</code>
            </div>

            <div class="tag-card">
                <h3>element.getBoundingClientRect()</h3>
                <p><strong>C'est quoi ?</strong> Retourne la taille et position de l'√©l√©ment par rapport au VIEWPORT (la fen√™tre visible), pas √† la page.</p>
                <p><strong>Pourquoi ?</strong> LA m√©thode pour d√©tecter si un √©l√©ment est visible, positionner des √©l√©ments absolus (tooltips, menus), animations au scroll.</p>
                <p><strong>Astuce :</strong> Si rect.top < window.innerHeight et rect.bottom > 0, l'√©l√©ment est visible √† l'√©cran.</p>
                <code>const rect = element.getBoundingClientRect();
const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
// Tooltip au bon endroit
tooltip.style.top = rect.bottom + 10 + 'px';
tooltip.style.left = rect.left + 'px';</code>
            </div>

            <div class="tag-card">
                <h3>window.scrollTo() / window.scrollBy()</h3>
                <p><strong>C'est quoi ?</strong> scrollTo() : scroll √† une position absolue. scrollBy() : scroll relatif (ajoute √† la position actuelle).</p>
                <p><strong>Pourquoi ?</strong> Contr√¥ler le scroll de la page : bouton "Retour en haut", navigation par sections, scroll programmatique.</p>
                <p><strong>Option smooth :</strong> Ajoute { behavior: 'smooth' } pour une animation fluide au lieu d'un saut instantan√©.</p>
                <code>// Retour en haut avec animation
window.scrollTo({ top: 0, behavior: 'smooth' });
// Scroll 200px vers le bas
window.scrollBy({ top: 200, behavior: 'smooth' });</code>
            </div>

            <div class="tag-card">
                <h3>element.scrollIntoView()</h3>
                <p><strong>C'est quoi ?</strong> Scroll automatiquement pour rendre l'√©l√©ment visible dans le viewport. Support des options d'animation.</p>
                <p><strong>Pourquoi ?</strong> Navigation vers un √©l√©ment : scroll vers une erreur de formulaire, navigation par ancres, focus sur un r√©sultat de recherche.</p>
                <p><strong>Options :</strong> behavior:'smooth' pour l'animation, block:'center' pour centrer verticalement, inline:'nearest' pour l'horizontal.</p>
                <code>// Scroll vers la premi√®re erreur
const firstError = document.querySelector('.error');
firstError?.scrollIntoView({ behavior: 'smooth', block: 'center' });
// Scroll vers une section
document.getElementById('contact').scrollIntoView({ behavior: 'smooth' });</code>
            </div>
        </section>

        <section id="autres">
            <h2>üîß Autres M√©thodes Utiles</h2>

            <div class="tag-card">
                <h3>element.focus() / element.blur()</h3>
                <p><strong>C'est quoi ?</strong> focus() active l'√©l√©ment (curseur dedans pour les inputs), blur() retire le focus.</p>
                <p><strong>Pourquoi ?</strong> Am√©liorer l'UX : mettre le curseur automatiquement dans le champ de recherche, retirer le focus apr√®s validation.</p>
                <p><strong>Exemple concret :</strong> Quand tu ouvres un modal de connexion, mettre le focus direct sur le champ email.</p>
                <code>// Focus auto sur le champ de recherche
searchModal.addEventListener('open', () => {
    searchInput.focus();
});
// Retirer le focus apr√®s envoi
form.addEventListener('submit', () => submitBtn.blur());</code>
            </div>

            <div class="tag-card">
                <h3>element.click()</h3>
                <p><strong>C'est quoi ?</strong> D√©clenche un clic programmatique sur l'√©l√©ment, comme si l'utilisateur avait cliqu√©.</p>
                <p><strong>Pourquoi ?</strong> Pour automatiser des actions : ouvrir un file picker custom, soumettre un formulaire, d√©clencher un t√©l√©chargement.</p>
                <p><strong>Use case classique :</strong> Bouton personnalis√© qui d√©clenche le clic sur un input file cach√©.</p>
                <code>// Bouton custom pour upload de fichier
const customBtn = document.querySelector('.custom-upload-btn');
const fileInput = document.querySelector('input[type="file"]');
customBtn.addEventListener('click', () => {
    fileInput.click(); // Ouvre le s√©lecteur de fichiers
});</code>
            </div>

            <div class="tag-card">
                <h3>element.contains()</h3>
                <p><strong>C'est quoi ?</strong> V√©rifie si un √©l√©ment contient un autre √©l√©ment dans son arbre DOM. Retourne true/false.</p>
                <p><strong>Pourquoi ?</strong> D√©tecter les clics en dehors : fermer un menu si on clique √† l'ext√©rieur, fermer une modale au clic outside.</p>
                <p><strong>Pattern essentiel :</strong> Click outside to close - ferme un √©l√©ment si le clic est √† l'ext√©rieur.</p>
                <code>// Fermer le menu si clic en dehors
document.addEventListener('click', (e) => {
    if (!menu.contains(e.target) && !menuBtn.contains(e.target)) {
        menu.classList.remove('open');
    }
});</code>
            </div>

            <div class="tag-card">
                <h3>document.activeElement</h3>
                <p><strong>C'est quoi ?</strong> Retourne l'√©l√©ment qui a actuellement le focus (celui o√π le curseur est).</p>
                <p><strong>Pourquoi ?</strong> Savoir o√π est le focus : navigation au clavier, sauvegarder la position, g√©rer les raccourcis clavier selon le contexte.</p>
                <p><strong>Astuce :</strong> Si aucun √©l√©ment n'a le focus, activeElement retourne le &lt;body&gt;.</p>
                <code>// D√©sactiver les raccourcis clavier dans les inputs
document.addEventListener('keydown', (e) => {
    if (document.activeElement.tagName === 'INPUT') {
        return; // Ne pas g√©rer les raccourcis
    }
    // G√©rer les raccourcis...
});</code>
            </div>

            <div class="tag-card">
                <h3>document.hasFocus()</h3>
                <p><strong>C'est quoi ?</strong> V√©rifie si la page a le focus (l'utilisateur est sur cet onglet). Retourne true/false.</p>
                <p><strong>Pourquoi ?</strong> Mettre en pause des animations/vid√©os quand l'utilisateur change d'onglet, g√©rer les notifications.</p>
                <p><strong>Use case :</strong> √âconomiser les ressources en pausant les requ√™tes/animations quand l'onglet n'est pas actif.</p>
                <code>// Pause la vid√©o si l'utilisateur change d'onglet
window.addEventListener('blur', () => {
    if (!document.hasFocus()) video.pause();
});
window.addEventListener('focus', () => video.play());</code>
            </div>

            <div class="tag-card">
                <h3>element.isConnected</h3>
                <p><strong>C'est quoi ?</strong> V√©rifie si l'√©l√©ment est connect√© au DOM (existe dans la page). True = dans le DOM, false = supprim√©/en m√©moire.</p>
                <p><strong>Pourquoi ?</strong> √âviter les erreurs : v√©rifier qu'un √©l√©ment existe toujours avant de le manipuler, surtout dans les callbacks asynchrones.</p>
                <p><strong>Cas pratique :</strong> Un √©l√©ment peut √™tre supprim√© pendant une requ√™te async. V√©rifie isConnected avant de l'update.</p>
                <code>// V√©rifier avant de mettre √† jour apr√®s un fetch
fetch('/api/data').then(data => {
    if (element.isConnected) {
        element.textContent = data.value;
    }
});</code>
            </div>

            <div class="tag-card">
                <h3>DOMContentLoaded (√©v√©nement)</h3>
                <p><strong>C'est quoi ?</strong> √âv√©nement d√©clench√© quand le HTML est pars√© et le DOM construit, SANS attendre images/CSS.</p>
                <p><strong>Pourquoi ?</strong> Ex√©cuter ton JS d√®s que possible. Plus rapide que 'load'. C'est LE moment pour manipuler le DOM.</p>
                <p><strong>Best practice :</strong> Utilise DOMContentLoaded pour ton code principal. Utilise 'load' seulement si tu as besoin des images.</p>
                <code>document.addEventListener('DOMContentLoaded', () => {
    // Le DOM est pr√™t, tu peux tout manipuler
    initApp();
    attachEventListeners();
});</code>
            </div>

            <div class="tag-card">
                <h3>window.load (√©v√©nement)</h3>
                <p><strong>C'est quoi ?</strong> Se d√©clenche quand TOUT est charg√© : HTML, CSS, images, iframes, scripts externes.</p>
                <p><strong>Pourquoi ?</strong> Quand tu as besoin que les images soient charg√©es : calculer leur taille, cr√©er un masonry layout, pr√©loader complet.</p>
                <p><strong>Attention :</strong> Plus lent que DOMContentLoaded. N'utilise que si vraiment n√©cessaire.</p>
                <code>window.addEventListener('load', () => {
    // Tout est charg√©, m√™me les images
    const imgHeight = heroImage.offsetHeight;
    initMasonryLayout();
    hideLoader();
});</code>
            </div>

            <div class="tag-card">
                <h3>IntersectionObserver</h3>
                <p><strong>C'est quoi ?</strong> API moderne pour observer quand un √©l√©ment entre/sort du viewport. Performant, pas besoin d'√©couter le scroll.</p>
                <p><strong>Pourquoi ?</strong> Lazy loading d'images (charge seulement si visible), animations au scroll, infinite scroll, analytics (temps de visibilit√©).</p>
                <p><strong>Avantage :</strong> Beaucoup plus performant que d'√©couter l'√©v√©nement scroll et calculer getBoundingClientRect.</p>
                <code>// Lazy loading d'images
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.src = entry.target.dataset.src;
            observer.unobserve(entry.target);
        }
    });
});
document.querySelectorAll('img[data-src]').forEach(img => observer.observe(img));</code>
            </div>

            <div class="tag-card">
                <h3>MutationObserver</h3>
                <p><strong>C'est quoi ?</strong> Observe les changements dans le DOM : √©l√©ments ajout√©s/supprim√©s, attributs modifi√©s, texte chang√©.</p>
                <p><strong>Pourquoi ?</strong> R√©agir aux changements du DOM : adapter l'UI quand du contenu est ajout√© dynamiquement, cr√©er des composants r√©actifs.</p>
                <p><strong>Use case :</strong> D√©tecter quand des messages sont ajout√©s √† un chat pour auto-scroll, r√©initialiser des listeners.</p>
                <code>const observer = new MutationObserver((mutations) => {
    mutations.forEach(mutation => {
        if (mutation.addedNodes.length) {
            // Des √©l√©ments ont √©t√© ajout√©s
            chatBox.scrollTop = chatBox.scrollHeight;
        }
    });
});
observer.observe(chatBox, { childList: true });</code>
            </div>
        </section>
    </main>

    <footer>
        <p>‚ö° Guide JavaScript & DOM pour ma√Ætriser l'interactivit√© de tes pages !</p>
        <p>
            <a href="html-guide.html">‚Üê Guide HTML</a> |
            <a href="css-guide.html">Guide CSS</a> |
            <a href="bootstrap-guide.html">Guide Bootstrap</a> |
            <a href="git-guide.html">Guide Git</a>
        </p>
    </footer>

    <script>
        const searchInput = document.getElementById('searchInput');
        const allCards = document.querySelectorAll('.tag-card');

        searchInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase().trim();

            // R√©initialiser tous les backgrounds
            allCards.forEach(card => {
                card.style.backgroundColor = '';
            });

            if (searchTerm === '') return;

            // Chercher dans tous les h3
            allCards.forEach(card => {
                const h3 = card.querySelector('h3');
                const methodName = h3.textContent.toLowerCase().trim();

                if (methodName.includes(searchTerm)) {
                    // Surligner la carte
                    card.style.backgroundColor = '#fff3cd';

                    // Scroller vers le premier r√©sultat
                    if (document.querySelector('.tag-card[style*="background-color"]') === card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });
        });
    </script>
</body>
</html>